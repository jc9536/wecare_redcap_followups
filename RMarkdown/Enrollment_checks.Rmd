---
title: "WeCare Enrollment Checks"
author: "Generated from STATA do-file"
output:
  html_document:
    toc: true
    toc_depth: 3
    number_sections: true
---

# 1) Run Packages
```{r message=FALSE, warning=FALSE}
# ========================= PACKAGES =========================
library(readr)
library(dplyr)
library(tidyr)
library(stringr)
library(lubridate)
library(gt)
```

# 2) User Inputs
```{r message=FALSE, warning=FALSE}
# ========================= USER INPUTS ======================
# File
OUT_DIR   <- OUT_DIR %||% "."   # if OUT_DIR not set
csv_path  <- file.path(OUT_DIR, "dat_merged.csv") # => replace entire line with location of .csv file for analysis within quotation (e.g.: "desktop/dat_merged.csv")

# Which datasets to run?
RUN_CURRENT <- TRUE
RUN_LOCKED  <- TRUE

# Which tables to render?
SHOW_ENROLL          <- TRUE
SHOW_FOLLOWUP        <- TRUE     # outreach summary (3m/6m)
SHOW_OUTREACH_WEEKLY <- TRUE
SHOW_OUTREACH_DAILY  <- TRUE

# Labels / dates / targets
DATA_LOCK  <- as.Date("2025-10-15")
AS_OF_DATE <- as.Date("2025-10-29")
TARGET_H   <- 345
TARGET_K   <- 630

# Weeks to include (any day inside the week is fine)
WEEKS_INPUT <- as.Date(c("2025-09-22","2025-09-29","2025-10-06","2025-10-17", "2025-10-29"))

# 3m/6m “active if unscheduled but sched_min < cutoff” (Stata td(30sep2025))
CUTOFF_3M <- as.Date("2025-09-30")
CUTOFF_6M <- as.Date("2025-09-30")
```

# 3) Helper Functions
```{r warning=FALSE, message=FALSE}
# ========================= HELPERS ==========================
`%||%` <- function(a,b) if (is.null(a)) b else a

# Parse mixed date representations to Date (drops time).
# Adds: SAS/Stata daily serials (origin = 1960-01-01).
to_date_smart <- function(x,
                          tz_epoch = "UTC",
                          tz_local = "America/New_York",
                          min_year = 2010,
                          max_year = 2100) {

  x_chr <- as.character(x)
  n <- length(x_chr)
  out <- rep(as.Date(NA), n)

  is_digits <- grepl("^\\d+$", x_chr)
  idx_num   <- which(is_digits)

  clip_years <- function(d) {
    bad <- !is.na(d) & (as.integer(format(d, "%Y")) < min_year |
                        as.integer(format(d, "%Y")) > max_year)
    d[bad] <- as.Date(NA)
    d
  }

    if (length(idx_num)) {
    num <- suppressWarnings(as.numeric(x_chr[idx_num]))
    nchar_num <- nchar(x_chr[idx_num])

    # 8-digit YYYYMMDD
    is_yyyymmdd <- nchar_num == 8 & grepl("^(19|20)\\d{6}$", x_chr[idx_num])

    # Excel serials (modern)
    is_excel <- !is_yyyymmdd & !is.na(num) & num >= 25569 & num <= 60000

    # Epoch seconds/milliseconds
    is_epoch_ms <- !is.na(num) & num > 1e12
    is_epoch_s  <- !is.na(num) & num > 1e8 & num <= 1e12

    # >>> NEW: UNIX *days* since 1970-01-01 (typical range covers 2011–~2060+)
    is_unix_days <- !is_yyyymmdd & !is_excel & !is_epoch_ms & !is_epoch_s &
                    !is.na(num) & num >= 15000 & num <= 40000

    # SAS/Stata daily serials (days since 1960-01-01)
    # Exclude other classes incl. unix-days
    is_sas_stata <- !is_yyyymmdd & !is_excel & !is_epoch_ms & !is_epoch_s &
                    !is_unix_days & !is.na(num) & num >= -3650 & num <= 32000

    # YYYYMMDD
    if (any(is_yyyymmdd)) {
      y <- as.integer(substr(x_chr[idx_num][is_yyyymmdd], 1, 4))
      m <- as.integer(substr(x_chr[idx_num][is_yyyymmdd], 5, 6))
      d <- as.integer(substr(x_chr[idx_num][is_yyyymmdd], 7, 8))
      d_ymd <- suppressWarnings(as.Date(sprintf("%04d-%02d-%02d", y, m, d)))
      out[idx_num[is_yyyymmdd]] <- clip_years(d_ymd)
    }

    # Excel
    if (any(is_excel)) {
      d_xl <- as.Date(num[is_excel], origin = "1899-12-30")
      out[idx_num[is_excel]] <- clip_years(d_xl)
    }

    # >>> NEW: UNIX days
    if (any(is_unix_days)) {
      d_ud <- as.Date(num[is_unix_days], origin = "1970-01-01")
      out[idx_num[is_unix_days]] <- clip_years(d_ud)
    }

    # SAS/Stata
    if (any(is_sas_stata)) {
      d_ss <- as.Date(num[is_sas_stata], origin = "1960-01-01")
      out[idx_num[is_sas_stata]] <- clip_years(d_ss)
    }

    # Epoch ms
    if (any(is_epoch_ms)) {
      s <- num[is_epoch_ms] / 1000
      posix <- as.POSIXct(s, origin = "1970-01-01", tz = tz_epoch)
      out[idx_num[is_epoch_ms]] <- clip_years(as.Date(as.POSIXct(format(posix, tz = tz_local, usetz = TRUE), tz = tz_local)))
    }

    # Epoch s
    if (any(is_epoch_s)) {
      s <- num[is_epoch_s]
      posix <- as.POSIXct(s, origin = "1970-01-01", tz = tz_epoch)
      out[idx_num[is_epoch_s]] <- clip_years(as.Date(as.POSIXct(format(posix, tz = tz_local, usetz = TRUE), tz = tz_local)))
    }
  }

  # Non-numeric strings
  idx_str <- which(!is_digits)
  if (length(idx_str)) {
    x_s <- x_chr[idx_str]

    d1 <- suppressWarnings(lubridate::ymd(x_s, quiet = TRUE))
    miss <- is.na(d1)
    if (any(miss)) { d2 <- suppressWarnings(lubridate::ymd_hm (x_s[miss], quiet = TRUE)); d1[miss] <- d2; miss <- is.na(d1) }
    if (any(miss)) { d3 <- suppressWarnings(lubridate::ymd_hms(x_s[miss], quiet = TRUE)); d1[miss] <- d3; miss <- is.na(d1) }
    if (any(miss)) { d4 <- suppressWarnings(lubridate::mdy    (x_s[miss], quiet = TRUE)); d1[miss] <- d4; miss <- is.na(d1) }
    if (any(miss)) { d5 <- suppressWarnings(lubridate::mdy_hm (x_s[miss], quiet = TRUE)); d1[miss] <- d5; miss <- is.na(d1) }
    if (any(miss)) { d6 <- suppressWarnings(lubridate::mdy_hms(x_s[miss], quiet = TRUE)); d1[miss] <- d6 }

    out[idx_str] <- clip_years(as.Date(d1))
  }

  out
}

# Stata-style left-to-right coalesce for strings (treat "" as missing)
coalesce_chr <- function(...) {
  args <- list(...)
  args <- lapply(args, \(v) replace(v, is.na(v) | v == "", NA))
  out <- args[[1]]
  for (i in seq_along(args)[-1]) out <- ifelse(is.na(out), args[[i]], out)
  out
}

# Canonical site code (H/K) from site_id or ID prefix
site_id_from <- function(site_id, id_like) {
  sid <- toupper(trimws(as.character(site_id)))
  idl <- as.character(id_like)
  dplyr::case_when(
    sid %in% c("H","K") ~ sid,
    str_starts(idl, "H-") ~ "H",
    str_starts(idl, "K-") ~ "K",
    TRUE ~ NA_character_
  )
}

# Count H/K + Total under a logical filter
count_by_site <- function(df, filter_expr = TRUE) {
  tmp <- dplyr::filter(df, {{ filter_expr }})
  tibble(
    Harlem = sum(tmp$site_id == "H", na.rm = TRUE),
    Kings  = sum(tmp$site_id == "K", na.rm = TRUE)
  ) |> mutate(Total = Harlem + Kings)
}

# Robust parser for outreach dates (strings + numeric serials)
as_date_guess <- function(x,
                          unix_origin  = as.Date("1970-01-01"),
                          excel_origin = as.Date("1899-12-30")) {
  if (inherits(x, "Date"))   return(x)
  if (inherits(x, "POSIXt")) return(as.Date(x))
  s <- as.character(x)
  d <- as.Date(
    s,
    tryFormats = c(
      "%Y-%m-%d",
      "%Y-%m-%d %H:%M:%S",
      "%m/%d/%Y",
      "%m/%d/%y",
      "%m/%d/%Y %H:%M",
      "%m/%d/%y %H:%M",
      "%m/%d/%Y %I:%M %p",
      "%m/%d/%y %I:%M %p"
    ),
    optional = TRUE
  )
  need_num <- is.na(d) & grepl("^\\s*\\d+\\s*$", s)
  if (any(need_num)) {
    v <- as.numeric(s[need_num])
    is_unix  <- v >= 15000 & v < 30000
    is_excel <- v >= 40000 & v < 80000
    d_sub <- rep(as.Date(NA), length(v))
    d_sub[is_unix]  <- as.Date(v[is_unix],  origin = unix_origin)
    d_sub[is_excel] <- as.Date(v[is_excel], origin = excel_origin)
    d[need_num] <- d_sub
  }
  d
}
```

# 4) Load & Clean the Dataset 
```{r message=FALSE, warning=FALSE}
# ========================= LOAD + CLEAN =====================
raw <- readr::read_csv(csv_path, show_col_types = FALSE)

# Replace literal "NA" strings with blanks (Stata foreach)
raw <- raw |> mutate(across(everything(), ~ ifelse(.x %in% c("NA"), "", .x)))

# Coerce numeric-like fields (Stata: destring, ignore("NA"))
raw <- raw |>
  mutate(
    treatment    = suppressWarnings(as.integer(as.character(treatment))),
    cassy_result = suppressWarnings(as.integer(as.character(cassy_result)))
  )

# Build participant id from youth then caregiver
# ppid_y  <- str_sub(as.character(raw$participant_id), 1, 7)
# ppid_cg <- str_sub(as.character(raw$p_participant_id), 1, 7)

# Merge date (youth→caregiver→screen→baseline→p_baseline), then drop blanks
# base_df <- raw |>
#  mutate(
#    record_id = if_else(is.na(ppid_y) | ppid_y == "", ppid_cg, ppid_y),
#   merged_date_chr  = coalesce_chr(
#      as.character(ps_date),
#      as.character(p_ps_date),
#      as.character(screen_doe),
#      as.character(date_baseline),
#      as.character(p_date_baseline)
#    )
#  ) |>
#  filter(!is.na(merged_date_chr) & merged_date_chr != "") |>
#  mutate(
#    merged_date = to_date_smart(merged_date_chr),
#    site_code   = site_code_from(site_id, coalesce_chr(record_id, participant_id, p_participant_id))
#  )

# Locked snapshot (same cleaning; just filter by merged_date)
locked_df <- raw |> filter(merged_date <= DATA_LOCK)
```

# 5) Build Tables 
```{r warning=FALSE, message=FALSE}
# ========================= TABLE BUILDERS ===================
# Outreach recode (Stata-equivalent)
recode_outreach <- function(status, sched_min, cutoff) {
  dplyr::case_when(
    status == 1 ~ 1L,
    status == 2 ~ 2L,
    status >= 3 & status <= 5 ~ 3L,
    status == 6 ~ 4L,
    status == 7 ~ 5L,
    is.na(status) & !is.na(sched_min) & sched_min < cutoff ~ 3L,
    TRUE ~ NA_integer_
  )
}

# Safe outreach counter (ensures H/K exist)
count_outreach <- function(dd, var) {
  lvls <- c(1L,2L,3L,4L,5L)
  labs <- c("Completed","Scheduled","Active","Withdrawal","Missed")
  tmp <- dd %>%
    filter(!is.na(.data[[var]])) %>%
    mutate(cat = factor(.data[[var]], levels = lvls, labels = labs)) %>%
    count(cat, site_id, name = "n") %>%
    tidyr::pivot_wider(names_from = site_id, values_from = n, values_fill = 0)
  for (nm in c("H","K")) if (!(nm %in% names(tmp))) tmp[[nm]] <- 0L
  tmp %>%
    mutate(H = coalesce(H, 0L), K = coalesce(K, 0L)) %>%
    tidyr::complete(cat = factor(labs, levels = labs), fill = list(H = 0L, K = 0L)) %>%
    arrange(cat) %>%
    mutate(Total = H + K) %>%
    rename(Item = cat)
}

# Build event log (3m + 6m outreach columns → long)
make_events <- function(df) {
  cols_3m <- c("follow_outreach_1_3m", paste0("follow_outreachdate_", 2:15, "_3m"))
  cols_6m <- paste0("follow_outreachdate_", 1:15, "_6m")
  mk <- function(d, cols, lab) {
    cols <- intersect(cols, names(d))
    if (!length(cols)) return(tibble(date = as.Date(character()), window = character()))
    d %>%
      select(all_of(cols)) %>%
      pivot_longer(everything(), names_to = "var", values_to = "raw") %>%
      mutate(date = as_date_guess(raw), window = lab) %>%
      filter(!is.na(date))
  }
  bind_rows(
    mk(df, cols_3m, "3m"),
    mk(df, cols_6m, "6m")
  ) %>% mutate(window = factor(window, levels = c("3m","6m")))
}

pad_windows <- function(df) {
  if (!("3m" %in% names(df))) df[["3m"]] <- 0L
  if (!("6m" %in% names(df))) df[["6m"]] <- 0L
  df
}

daily_table_for_week <- function(events, any_date, label) {
  week_mon <- floor_date(as.Date(any_date), "week", week_start = 1)
  days_mf  <- tibble(date = seq.Date(week_mon, week_mon + days(6), by = "day")) %>%
    filter(wday(date, week_start = 1) <= 5)
  day_counts <- events %>%
    filter(date >= week_mon, date <= week_mon + days(6)) %>%
    count(date, window, name = "n") %>%
    pivot_wider(names_from = window, values_from = n, values_fill = 0)
  wid <- left_join(days_mf, day_counts, by = "date") %>%
    pad_windows() %>%
    transmute(
      date,
      `3 months` = as.integer(`3m`),
      `6 months` = as.integer(`6m`),
      Total      = `3 months` + `6 months`
    ) %>%
    arrange(date)
  gt(wid) %>%
    tab_header(
      title = md(paste0(
        "**Number of Outreaches per Day**<br>",
        "<span style='font-size:12px'>", label,
        " — Week of ", format(week_mon, "%m/%d/%Y"), "</span>"
      ))
    ) %>%
    fmt_date(columns = date, date_style = 3) %>%
    summary_rows(groups = NULL,
                 columns = c(`3 months`,`6 months`, Total),
                 fns = list(`Weekly Total` = ~sum(.x, na.rm = TRUE))) %>%
    cols_label(date = "Date") %>%
    fmt_number(columns = c(`3 months`, `6 months`, Total), decimals = 0)
}

build_all <- function(df,
                      as_of_date,
                      target_H, target_K,
                      weeks_input,
                      cutoff_3m = CUTOFF_3M,
                      cutoff_6m = CUTOFF_6M,
                      label = "Current data",
                      want_enroll = TRUE,
                      want_fu     = TRUE,
                      want_weekly = TRUE,
                      want_daily  = TRUE) {

  out <- list()

  # ----- ENROLLMENT -----
  if (want_enroll) {
    approached     <- df %>% distinct(record_id, site_id) %>% count_by_site()
    enrolled_total <- count_by_site(df, !is.na(treatment))
    enrolled_ctrl  <- count_by_site(df, treatment == 0)
    enrolled_tx    <- count_by_site(df, treatment == 1)
    cassy_plus     <- count_by_site(df, treatment == 1 & cassy_result == 1)

    target_row <- tibble(Harlem = target_H, Kings = target_K) %>% mutate(Total = Harlem + Kings)

    enroll_tbl <- bind_rows(
      tibble(Item = "Total approached") %>% bind_cols(approached),
      tibble(Item = paste0("Target enrollment (as of ", format(as_of_date, "%m/%d"), ")")) %>% bind_cols(target_row),
      tibble(Item = "Total enrollment")              %>% bind_cols(enrolled_total),
      tibble(Item = "Total Control Group")           %>% bind_cols(enrolled_ctrl),
      tibble(Item = "Total Intervention Group")      %>% bind_cols(enrolled_tx),
      tibble(Item = "Total CASSY+/CFS Intervention") %>% bind_cols(cassy_plus)
    )

    out$enroll_gt <- enroll_tbl %>%
      gt(rowname_col = "Item") %>%
      tab_header(
        title    = md("**WeCare Youth Enrollment**"),
        subtitle = md(paste0(label, " — as of ", format(as_of_date, "%m/%d/%Y")))
      ) %>%
      cols_label(Harlem = "Harlem", Kings = "Kings", Total = "Total") %>%
      fmt_number(columns = c(Harlem, Kings, Total), decimals = 0)
  }

  # ----- FOLLOW-UP OUTREACH SUMMARY (3m & 6m) -----
  if (want_fu) {
    dat_fu <- df %>%
      mutate(
        follow_visitstatus_3m = suppressWarnings(as.integer(as.character(follow_visitstatus_3m))),
        follow_visitstatus_6m = suppressWarnings(as.integer(as.character(follow_visitstatus_6m))),
        follow_sch_min_3m = as_date_guess(follow_sch_min_3m),
        follow_sch_min_6m = as_date_guess(follow_sch_min_6m),
        outreach_3m = recode_outreach(follow_visitstatus_3m, follow_sch_min_3m, cutoff_3m),
        outreach_6m = recode_outreach(follow_visitstatus_6m, follow_sch_min_6m, cutoff_6m)
      )

    fu3_tbl <- count_outreach(dat_fu, "outreach_3m")
    fu6_tbl <- count_outreach(dat_fu, "outreach_6m")

    out$fu3_gt <- fu3_tbl %>%
      gt(rowname_col = "Item") %>%
      tab_header(title = md(paste0("**WeCare Follow-Up Assessments**<br>",
                                   "<span style='font-size:12px'>3-month — ", label, "</span>"))) %>%
      cols_label(H = "Harlem", K = "Kings", Total = "Total") %>%
      fmt_number(columns = c(H, K, Total), decimals = 0)

    out$fu6_gt <- fu6_tbl %>%
      gt(rowname_col = "Item") %>%
      tab_header(title = md(paste0("**WeCare Follow-Up Assessments**<br>",
                                   "<span style='font-size:12px'>6-month — ", label, "</span>"))) %>%
      cols_label(H = "Harlem", K = "Kings", Total = "Total") %>%
      fmt_number(columns = c(H, K, Total), decimals = 0)
  }

  # ----- OUTREACHES PER WEEK / PER DAY -----
  if (want_weekly || want_daily) {
    events <- make_events(df)

    if (want_weekly) {
      weekly_rows <- lapply(weeks_input, function(w) {
        week_mon <- floor_date(as.Date(w), "week", week_start = 1)
        cnt <- events %>%
          filter(date >= week_mon, date <= week_mon + days(6)) %>%
          count(window, name = "n") %>%
          pivot_wider(names_from = window, values_from = n, values_fill = 0) %>%
          pad_windows()
        if (nrow(cnt) == 0) {
          tibble(`Week of:` = format(week_mon, "%m/%d/%Y"),
                 `3 months` = 0L, `6 months` = 0L, Total = 0L)
        } else {
          cnt %>% transmute(
            `Week of:` = format(week_mon, "%m/%d/%Y"),
            `3 months` = as.integer(`3m`),
            `6 months` = as.integer(`6m`),
            Total      = `3 months` + `6 months`
          )
        }
      }) |> bind_rows() |>
        arrange(desc(as.Date(`Week of:`, format = "%m/%d/%Y")))

      out$weekly_gt <- gt(weekly_rows) %>%
        tab_header(title = md(paste0("**Number of Outreaches per Week**<br>",
                                     "<span style='font-size:12px'>", label, "</span>"))) %>%
        fmt_number(columns = c(`3 months`, `6 months`, Total), decimals = 0)
    }

    if (want_daily) {
      out$daily_gts <- lapply(weeks_input, function(w) daily_table_for_week(events, w, label))
    }
  }

  out
}
```

# Table Output 
```{r warning=FALSE, message=FALSE}
# ========================= RUN BUILDS =======================

if (RUN_CURRENT) {
  current <- build_all(
    df          = raw,
    as_of_date  = AS_OF_DATE,
    target_H    = TARGET_H,
    target_K    = TARGET_K,
    weeks_input = WEEKS_INPUT,
    label       = "Current data",
    want_enroll = SHOW_ENROLL,
    want_fu     = SHOW_FOLLOWUP,
    want_weekly = SHOW_OUTREACH_WEEKLY,
    want_daily  = SHOW_OUTREACH_DAILY
  )

  if (SHOW_ENROLL)          print(current$enroll_gt)
  if (SHOW_FOLLOWUP)       { print(current$fu3_gt); print(current$fu6_gt) }
  if (SHOW_OUTREACH_WEEKLY) print(current$weekly_gt)
  if (SHOW_OUTREACH_DAILY)  for (g in current$daily_gts) print(g)
}

if (RUN_LOCKED) {
  locked <- build_all(
    df          = locked_df,
    as_of_date  = AS_OF_DATE,
    target_H    = TARGET_H,
    target_K    = TARGET_K,
    weeks_input = WEEKS_INPUT,
    label       = paste0("Data locked < ", format(DATA_LOCK, "%m/%d/%Y")),
    want_enroll = SHOW_ENROLL,
    want_fu     = SHOW_FOLLOWUP,
    want_weekly = SHOW_OUTREACH_WEEKLY,
    want_daily  = SHOW_OUTREACH_DAILY
  )

  if (SHOW_ENROLL)          print(locked$enroll_gt)
  if (SHOW_FOLLOWUP)       { print(locked$fu3_gt); print(locked$fu6_gt) }
  if (SHOW_OUTREACH_WEEKLY) print(locked$weekly_gt)
  if (SHOW_OUTREACH_DAILY)  for (g in locked$daily_gts) print(g)
}
```