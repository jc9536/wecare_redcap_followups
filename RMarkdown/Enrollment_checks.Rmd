---
title: "WeCare Enrollment Checks"
author: "Generated from STATA do-file"
output:
  html_document:
    toc: true
    toc_depth: 3
    number_sections: true
---

# 1) Run Packages
```{r message=FALSE, warning=FALSE}
# ========================= PACKAGES =========================
library(readr)
library(dplyr)
library(tidyr)
library(stringr)
library(lubridate)
library(gt)
```

# 2) User Inputs
```{r message=FALSE, warning=FALSE}
# ========================= USER INPUTS ======================
# File
OUT_DIR   <- OUT_DIR %||% "/Users/jaimiechin/Library/CloudStorage/Box-Box/WeCare (Michael Wu)/Data/cleaned/New ETL Output"   # if OUT_DIR not set
csv_path  <- file.path(OUT_DIR, "dat_merged.csv") # => replace entire line with location of .csv file for analysis within quotation (e.g.: "desktop/dat_merged.csv")

# Which datasets to run?
RUN_CURRENT <- TRUE
RUN_LOCKED  <- FALSE

# Which tables to render?
SHOW_ENROLL          <- TRUE
SHOW_ENROLL_WEEKLY   <- TRUE
SHOW_FOLLOWUP        <- TRUE     # outreach summary (3m/6m)
SHOW_OUTREACH_WEEKLY <- TRUE
SHOW_OUTREACH_DAILY  <- TRUE

# Labels / dates / targets
DATA_LOCK  <- as.Date("2026-01-01")
AS_OF_DATE <- as.Date("2026-02-17")

# Weeks to include (any day inside the week is fine)
WEEKS_INPUT <- as.Date(c("2026-02-04", "2026-02-09", "2026-02-17"))

# 3m/6m “active if unscheduled but sched_min < cutoff” (Stata td(30sep2025))
CUTOFF_3M <- as.Date("2026-01-01")
CUTOFF_6M <- as.Date("2026-01-01")
```

# 3) Helper Functions
```{r warning=FALSE, message=FALSE}
# ========================= HELPERS ==========================
`%||%` <- function(a,b) if (is.null(a)) b else a

# Parse mixed date representations to Date (drops time).
# Adds: SAS/Stata daily serials (origin = 1960-01-01).
to_date_smart <- function(x,
                          tz_epoch = "UTC",
                          tz_local = "America/New_York",
                          min_year = 2010,
                          max_year = 2100) {

  x_chr <- as.character(x)
  n <- length(x_chr)
  out <- rep(as.Date(NA), n)

  is_digits <- grepl("^\\d+$", x_chr)
  idx_num   <- which(is_digits)

  clip_years <- function(d) {
    bad <- !is.na(d) & (as.integer(format(d, "%Y")) < min_year |
                        as.integer(format(d, "%Y")) > max_year)
    d[bad] <- as.Date(NA)
    d
  }

    if (length(idx_num)) {
    num <- suppressWarnings(as.numeric(x_chr[idx_num]))
    nchar_num <- nchar(x_chr[idx_num])

    # 8-digit YYYYMMDD
    is_yyyymmdd <- nchar_num == 8 & grepl("^(19|20)\\d{6}$", x_chr[idx_num])

    # Excel serials (modern)
    is_excel <- !is_yyyymmdd & !is.na(num) & num >= 25569 & num <= 60000

    # Epoch seconds/milliseconds
    is_epoch_ms <- !is.na(num) & num > 1e12
    is_epoch_s  <- !is.na(num) & num > 1e8 & num <= 1e12

    # >>> NEW: UNIX *days* since 1970-01-01 (typical range covers 2011–~2060+)
    is_unix_days <- !is_yyyymmdd & !is_excel & !is_epoch_ms & !is_epoch_s &
                    !is.na(num) & num >= 15000 & num <= 40000

    # SAS/Stata daily serials (days since 1960-01-01)
    # Exclude other classes incl. unix-days
    is_sas_stata <- !is_yyyymmdd & !is_excel & !is_epoch_ms & !is_epoch_s &
                    !is_unix_days & !is.na(num) & num >= -3650 & num <= 32000

    # YYYYMMDD
    if (any(is_yyyymmdd)) {
      y <- as.integer(substr(x_chr[idx_num][is_yyyymmdd], 1, 4))
      m <- as.integer(substr(x_chr[idx_num][is_yyyymmdd], 5, 6))
      d <- as.integer(substr(x_chr[idx_num][is_yyyymmdd], 7, 8))
      d_ymd <- suppressWarnings(as.Date(sprintf("%04d-%02d-%02d", y, m, d)))
      out[idx_num[is_yyyymmdd]] <- clip_years(d_ymd)
    }

    # Excel
    if (any(is_excel)) {
      d_xl <- as.Date(num[is_excel], origin = "1899-12-30")
      out[idx_num[is_excel]] <- clip_years(d_xl)
    }

    # >>> NEW: UNIX days
    if (any(is_unix_days)) {
      d_ud <- as.Date(num[is_unix_days], origin = "1970-01-01")
      out[idx_num[is_unix_days]] <- clip_years(d_ud)
    }

    # SAS/Stata
    if (any(is_sas_stata)) {
      d_ss <- as.Date(num[is_sas_stata], origin = "1960-01-01")
      out[idx_num[is_sas_stata]] <- clip_years(d_ss)
    }

    # Epoch ms
    if (any(is_epoch_ms)) {
      s <- num[is_epoch_ms] / 1000
      posix <- as.POSIXct(s, origin = "1970-01-01", tz = tz_epoch)
      out[idx_num[is_epoch_ms]] <- clip_years(as.Date(as.POSIXct(format(posix, tz = tz_local, usetz = TRUE), tz = tz_local)))
    }

    # Epoch s
    if (any(is_epoch_s)) {
      s <- num[is_epoch_s]
      posix <- as.POSIXct(s, origin = "1970-01-01", tz = tz_epoch)
      out[idx_num[is_epoch_s]] <- clip_years(as.Date(as.POSIXct(format(posix, tz = tz_local, usetz = TRUE), tz = tz_local)))
    }
  }

  # Non-numeric strings
  idx_str <- which(!is_digits)
  if (length(idx_str)) {
    x_s <- x_chr[idx_str]

    d1 <- suppressWarnings(lubridate::ymd(x_s, quiet = TRUE))
    miss <- is.na(d1)
    if (any(miss)) { d2 <- suppressWarnings(lubridate::ymd_hm (x_s[miss], quiet = TRUE)); d1[miss] <- d2; miss <- is.na(d1) }
    if (any(miss)) { d3 <- suppressWarnings(lubridate::ymd_hms(x_s[miss], quiet = TRUE)); d1[miss] <- d3; miss <- is.na(d1) }
    if (any(miss)) { d4 <- suppressWarnings(lubridate::mdy    (x_s[miss], quiet = TRUE)); d1[miss] <- d4; miss <- is.na(d1) }
    if (any(miss)) { d5 <- suppressWarnings(lubridate::mdy_hm (x_s[miss], quiet = TRUE)); d1[miss] <- d5; miss <- is.na(d1) }
    if (any(miss)) { d6 <- suppressWarnings(lubridate::mdy_hms(x_s[miss], quiet = TRUE)); d1[miss] <- d6 }

    out[idx_str] <- clip_years(as.Date(d1))
  }

  out
}

# Stata-style left-to-right coalesce for strings (treat "" as missing)
coalesce_chr <- function(...) {
  args <- list(...)
  args <- lapply(args, \(v) replace(v, is.na(v) | v == "", NA))
  out <- args[[1]]
  for (i in seq_along(args)[-1]) out <- ifelse(is.na(out), args[[i]], out)
  out
}

# Canonical site code (H/K) from site_id or ID prefix
site_id_from <- function(site_id, id_like) {
  sid <- toupper(trimws(as.character(site_id)))
  idl <- as.character(id_like)
  dplyr::case_when(
    sid %in% c("H","K") ~ sid,
    str_starts(idl, "H-") ~ "H",
    str_starts(idl, "K-") ~ "K",
    TRUE ~ NA_character_
  )
}

# Count H/K + Total under a logical filter
count_by_site <- function(df, filter_expr = TRUE) {
  tmp <- dplyr::filter(df, {{ filter_expr }})
  tibble(
    Harlem = sum(tmp$site_id == "H", na.rm = TRUE),
    Kings  = sum(tmp$site_id == "K", na.rm = TRUE)
  ) |> mutate(Total = Harlem + Kings)
}

# Robust parser for outreach dates (strings + numeric serials)
as_date_guess <- function(x,
                          unix_origin  = as.Date("1970-01-01"),
                          excel_origin = as.Date("1899-12-30")) {
  if (inherits(x, "Date"))   return(x)
  if (inherits(x, "POSIXt")) return(as.Date(x))
  s <- as.character(x)
  d <- as.Date(
    s,
    tryFormats = c(
      "%Y-%m-%d",
      "%Y-%m-%d %H:%M:%S",
      "%m/%d/%Y",
      "%m/%d/%y",
      "%m/%d/%Y %H:%M",
      "%m/%d/%y %H:%M",
      "%m/%d/%Y %I:%M %p",
      "%m/%d/%y %I:%M %p"
    ),
    optional = TRUE
  )
  need_num <- is.na(d) & grepl("^\\s*\\d+\\s*$", s)
  if (any(need_num)) {
    v <- as.numeric(s[need_num])
    is_unix  <- v >= 15000 & v < 30000
    is_excel <- v >= 40000 & v < 80000
    d_sub <- rep(as.Date(NA), length(v))
    d_sub[is_unix]  <- as.Date(v[is_unix],  origin = unix_origin)
    d_sub[is_excel] <- as.Date(v[is_excel], origin = excel_origin)
    d[need_num] <- d_sub
  }
  d
}

parse_date_any_safe <- function(x) {
  x <- trimws(as.character(x))
  x[x == ""] <- NA_character_
  x[tolower(x) %in% c("na","n/a","null",".","missing")] <- NA_character_

  # keep date/time portion if timestamps exist
  x <- ifelse(!is.na(x), substr(x, 1, 19), NA_character_)

  # lubridate never throws here; it returns NA when it can’t parse
  dt <- suppressWarnings(
    lubridate::parse_date_time(
      x,
      orders = c(
        "Ymd HMS", "Ymd HM", "Ymd",
        "mdY HMS", "mdY HM", "mdY",
        "mdy",
        "Y/m/d", "m/d/Y", "m/d/y",
        "m-d-Y", "m-d-y"
      ),
      tz = "UTC",
      quiet = TRUE
    )
  )

  lubridate::as_date(dt)
}
```

# Projections Table + Weekday-based target calculator 
```{r}
# ==== PROJECTIONS TABLE (cumulative by site; BEGINNING of month anchors) ====
projections <- tibble::tribble(
  ~end_date,           ~Harlem, ~Kings,
  as.Date("2022-12-01"),   0,      0,
  as.Date("2023-04-01"),   0,      0,
  as.Date("2023-08-01"),   0,      0,
  as.Date("2023-12-01"),   0,      0,
  as.Date("2024-04-01"),   0,      0,
  as.Date("2024-08-01"),   0,     60,
  as.Date("2024-12-01"),  60,    160,
  as.Date("2025-04-01"), 135,    280,
  as.Date("2025-08-01"), 275,    497,
  as.Date("2025-12-01"), 415,    714,   # << December is 12/01
  as.Date("2026-04-01"), 555,    931,
  as.Date("2026-08-01"), 695,   1148,
  as.Date("2026-12-01"), 836,   1364,
  as.Date("2027-04-01"), 836,   1364
) %>% mutate(Total = Harlem + Kings)

# Quarter/term start that leads to each reporting endpoint
period_start_for <- function(end_date) {
  m <- lubridate::month(end_date); y <- lubridate::year(end_date)
  if      (m == 4)  as.Date(sprintf("%04d-01-01", y))  # Jan–Apr -> Apr 30 end
  else if (m == 8)  as.Date(sprintf("%04d-05-01", y))  # May–Aug -> Aug 31 end
  else if (m == 12) as.Date(sprintf("%04d-09-01", y))  # Sep–Dec -> Dec 31 end
  else              stop("Unexpected anchor month in projections.")
}

# --- helpers to compute nth/last weekday of a month ---
nth_wday <- function(year, month, wday_target, n, week_start = 1L) {
  # wday_target: 1=Mon ... 7=Sun when week_start=1
  first <- as.Date(sprintf("%04d-%02d-01", year, month))
  # day-of-week for the 1st of month under Monday=1
  w1 <- lubridate::wday(first, week_start = week_start)
  # days to add to reach first target weekday
  offset <- (wday_target - w1) %% 7
  first_target <- first + offset
  first_target + 7L * (n - 1L)
}
last_wday <- function(year, month, wday_target, week_start = 1L) {
  last <- lubridate::ceiling_date(as.Date(sprintf("%04d-%02d-01", year, month)), "month") - 1
  w_last <- lubridate::wday(last, week_start = week_start)
  offset <- (w_last - wday_target) %% 7
  last - offset
}

# --- observed date for fixed-date holidays (Sat -> Fri, Sun -> Mon) ---
observe_fixed_us <- function(d) {
  wd <- lubridate::wday(d, week_start = 1L) # Mon=1 ... Sun=7
  if (wd == 6L) d - 1L else if (wd == 7L) d + 1L else d
}

# --- US federal holidays (observed) for a year ---
us_federal_holidays <- function(year) {
  # floating mondays
  mlk        <- nth_wday(year, 1, 1, 3)   # 3rd Mon in Jan
  presidents <- nth_wday(year, 2, 1, 3)   # 3rd Mon in Feb
  memorial   <- last_wday(year, 5, 1)     # last Mon in May
  labor      <- nth_wday(year, 9, 1, 1)   # 1st Mon in Sep
  columbus   <- nth_wday(year, 10, 1, 2)  # 2nd Mon in Oct
  thanks     <- nth_wday(year, 11, 4, 4)  # 4th Thu in Nov (Thu=4)

  # fixed dates (observed)
  newyrs     <- observe_fixed_us(as.Date(sprintf("%04d-01-01", year)))
  juneteenth <- observe_fixed_us(as.Date(sprintf("%04d-06-19", year)))
  july4      <- observe_fixed_us(as.Date(sprintf("%04d-07-04", year)))
  veterans   <- observe_fixed_us(as.Date(sprintf("%04d-11-11", year)))
  xmas       <- observe_fixed_us(as.Date(sprintf("%04d-12-25", year)))

  sort(unique(c(newyrs, mlk, presidents, memorial, juneteenth, july4,
                labor, columbus, veterans, thanks, xmas)))
}

# --- holidays within [start, end] (inclusive) across all years spanned ---
us_holidays_between <- function(start, end) {
  if (is.na(start) || is.na(end) || end < start) return(as.Date(character()))
  yrs <- seq(lubridate::year(start), lubridate::year(end), by = 1L)
  hol <- unlist(lapply(yrs, us_federal_holidays), use.names = FALSE)
  hol[hol >= start & hol <= end]
}

# --- business days excluding U.S. federal holidays (observed) ---
bizdays_ex_us_holidays <- function(start, end, closed_interval = TRUE) {
  if (is.na(start) || is.na(end) || end < start) return(0L)
  rng <- seq.Date(start, end, by = "day")
  if (!closed_interval && length(rng) > 0) rng <- head(rng, -1L)  # [start, end)
  wk <- lubridate::wday(rng, week_start = 1L) <= 5L               # Mon–Fri
  hol <- us_holidays_between(min(rng), max(rng))
  sum(wk & !(rng %in% hol))
}

# Interpolate cumulative targets for AS_OF_DATE using business days excluding US holidays
calc_targets_asof <- function(as_of_date,
                              closed_interval = TRUE,
                              round_sites = TRUE) {

  # choose the next projection row on/after the as_of_date
  row_next <- projections %>% dplyr::filter(end_date >= as_of_date) %>% dplyr::slice_head(n = 1)
  if (nrow(row_next) == 0) row_next <- projections %>% dplyr::slice_tail(n = 1)

  idx_next <- which(projections$end_date == row_next$end_date)[1]
  row_prev <- if (idx_next > 1) projections[idx_next - 1, ] else projections[1, ]

  start_date <- row_prev$end_date

  # business-day fractions (Mon–Fri, excluding US federal holidays)
  num_bd <- bizdays_ex_us_holidays(start_date, as_of_date,  closed_interval = FALSE) # [start, as_of)
  den_bd <- bizdays_ex_us_holidays(start_date, row_next$end_date, closed_interval = FALSE) # [start, end)
  frac   <- if (den_bd > 0) pmin(pmax(num_bd / den_bd, 0), 1) else 0

  # interpolate by site (cumulative)
  H <- row_prev$Harlem + (row_next$Harlem - row_prev$Harlem) * frac
  K <- row_prev$Kings  + (row_next$Kings  - row_prev$Kings ) * frac
  T <- row_prev$Total  + (row_next$Total  - row_prev$Total ) * frac

  if (round_sites) {
    H_r <- round(H); K_r <- round(K); T_r <- round(T)
    # keep site sum aligned with rounded total
    adj <- T_r - (H_r + K_r)
    if (adj != 0) {
      frac_parts <- c(H - floor(H), K - floor(K))
      if (frac_parts[1] >= frac_parts[2]) H_r <- H_r + adj else K_r <- K_r + adj
    }
    dplyr::tibble(
      as_of_date, start_date, end_date = row_next$end_date,
      business_days_elapsed = num_bd,
      business_days_total   = den_bd,
      fraction_elapsed      = frac,
      Harlem_target = H_r, Kings_target = K_r, Total_target = H_r + K_r,
      Harlem_raw = H, Kings_raw = K, Total_raw = T
    )
  } else {
    dplyr::tibble(
      as_of_date, start_date, end_date = row_next$end_date,
      business_days_elapsed = num_bd,
      business_days_total   = den_bd,
      fraction_elapsed      = frac,
      Harlem_target = H, Kings_target  = K, Total_target  = T
    )
  }
}

# ---------- Week bounds (Mon..Sun) ----------
week_bounds <- function(any_date) {
  mon <- lubridate::floor_date(as.Date(any_date), "week", week_start = 1)
  tibble::tibble(week_mon = mon, week_sun = mon + lubridate::days(6))
}

# ---------- Weekly target delta from projections ----------
# Returns the *incremental* target for that week (not cumulative):
#   target(week_sun) - target(week_mon - 1)
weekly_target_for_week <- function(week_mon) {
  wb <- week_bounds(week_mon)
  t_end  <- calc_targets_asof(wb$week_sun, closed_interval = TRUE, round_sites = TRUE)
  t_prev <- calc_targets_asof(wb$week_mon - 1L, closed_interval = TRUE, round_sites = TRUE)

  tibble::tibble(
    week_mon,
    tgt_H_week = as.integer(t_end$Harlem_target - t_prev$Harlem_target),
    tgt_K_week = as.integer(t_end$Kings_target  - t_prev$Kings_target),
    tgt_T_week = as.integer(t_end$Total_target  - t_prev$Total_target)
  )
}

# ---------- Weekly Enrollment table (Actuals vs Target) ----------
# Uses merged_date as the authoritative enrollment date
weekly_enrollment_table <- function(df, weeks_input, as_of_date, label) {
  dd <- df %>%
    dplyr::mutate(
      site_norm   = site_id_from(site_id, coalesce_chr(participant_id, p_participant_id)),
      enroll_date = to_date_smart(merged_date)
    ) %>%
    dplyr::filter(
      !is.na(treatment),                 # enrolled only
      !is.na(site_norm),
      !is.na(enroll_date),
      enroll_date <= as_of_date,         # respect as-of cut
      lubridate::wday(enroll_date, week_start = 1) <= 5L  # Mon–Fri only
    )

  rows <- lapply(weeks_input, function(w) {
    wb <- week_bounds(w)
    # actuals this week
    cnt <- dd %>%
      dplyr::filter(enroll_date >= wb$week_mon, enroll_date <= wb$week_sun) %>%
      dplyr::count(site_norm, name = "n") %>%
      tidyr::pivot_wider(names_from = site_norm, values_from = n, values_fill = 0)
    H <- if ("H" %in% names(cnt)) cnt$H[1] else 0L
    K <- if ("K" %in% names(cnt)) cnt$K[1] else 0L
    T <- H + K

    # target deltas this week
    tdelta <- weekly_target_for_week(wb$week_mon)

    tibble::tibble(
      `Week of:`          = format(wb$week_mon, "%m/%d/%Y"),
      Harlem              = as.integer(H),
      Kings               = as.integer(K),
      Total               = as.integer(T),
      `Target Harlem`     = tdelta$tgt_H_week,
      `Target Kings`      = tdelta$tgt_K_week,
      `Target Total`      = tdelta$tgt_T_week
    )
  }) %>% dplyr::bind_rows() %>%
    dplyr::arrange(dplyr::desc(as.Date(`Week of:`, format = "%m/%d/%Y")))

  gt::gt(rows) %>%
    gt::tab_header(
      title = gt::md(paste0("**Weekly Enrollment vs Target**<br>",
                            "<span style='font-size:12px'>", label, "</span>"))
    ) %>%
    gt::fmt_number(columns = c(Harlem, Kings, Total, `Target Harlem`, `Target Kings`, `Target Total`), decimals = 0)
}
```

# 4) Load & Clean the Dataset 
```{r message=FALSE, warning=FALSE}
# ========================= LOAD + CLEAN =====================
raw <- readr::read_csv(csv_path, show_col_types = FALSE)

# Replace literal "NA" strings with blanks (Stata foreach)
raw <- raw |> mutate(across(everything(), ~ ifelse(.x %in% c("NA"), "", .x)))

# Coerce numeric-like fields (Stata: destring, ignore("NA"))
raw <- raw |>
  mutate(
    treatment    = suppressWarnings(as.integer(as.character(treatment))),
    cassy_result = suppressWarnings(as.integer(as.character(cassy_result)))
  )

# Build participant id from youth then caregiver
# ppid_y  <- str_sub(as.character(raw$participant_id), 1, 7)
# ppid_cg <- str_sub(as.character(raw$p_participant_id), 1, 7)

# Merge date (youth→caregiver→screen→baseline→p_baseline), then drop blanks
# base_df <- raw |>
#  mutate(
#    record_id = if_else(is.na(ppid_y) | ppid_y == "", ppid_cg, ppid_y),
#   merged_date_chr  = coalesce_chr(
#      as.character(ps_date),
#      as.character(p_ps_date),
#      as.character(screen_doe),
#      as.character(date_baseline),
#      as.character(p_date_baseline)
#    )
#  ) |>
#  filter(!is.na(merged_date_chr) & merged_date_chr != "") |>
#  mutate(
#    merged_date = to_date_smart(merged_date_chr),
#    site_code   = site_code_from(site_id, coalesce_chr(record_id, participant_id, p_participant_id))
#  )

# Locked snapshot (same cleaning; just filter by merged_date)
locked_df <- raw |> filter(merged_date <= DATA_LOCK)
```

```{r}
# ========================= LGBTQ+ FLAG (UPDATED FOR ADAM) ======================
is_lgbtq_sogi <- function(gender_code, trans_code, orient_code) {
  gender_code <- as.integer(gender_code)
  trans_code  <- as.integer(trans_code)
  orient_code <- as.integer(orient_code)

  # Non-informative / "skip" codes
  # 77 = don't know what this question is asking/means
  # 99 = do not want to answer
  noninfo_codes <- c(77L, 99L)

  # --- Sexual minority ---
  # 2–7 = Gay/Lesbian/Bi/Queer/Pan/Ace
  # 66  = I am not sure or questioning        -> LGBTQ+
  # 88  = I do not identify as any of these  -> LGBTQ+
  orient_minority <- orient_code %in% c(2L, 3L, 4L, 5L, 6L, 7L, 66L, 88L)

  # --- Gender minority ---
  # Assume:
  #   3,4,5 = Nonbinary / Genderfluid / Genderqueer
  #   66    = I am not sure or questioning        -> LGBTQ+
  #   88    = I do not identify as any of these  -> LGBTQ+
  gender_minority <- gender_code %in% c(3L, 4L, 5L, 66L, 88L)

  # --- Trans / questioning trans ---
  # 1  = Yes, I am transgender
  # 66 = I am not sure yet or I am questioning if I am transgender -> LGBTQ+
  trans_minority <- trans_code %in% c(1L, 66L)

  lgbtq <- orient_minority | gender_minority | trans_minority

  # If ALL three are non-informative / missing, set to NA (unknown SOGI)
  all_noninfo <- (is.na(gender_code) | gender_code %in% noninfo_codes) &
                 (is.na(trans_code)  | trans_code  %in% noninfo_codes) &
                 (is.na(orient_code) | orient_code %in% noninfo_codes)

  lgbtq[all_noninfo] <- NA

  lgbtq
}

# ========================= SIMPLE CASSY x LGBTQ+ SUMMARY ======================

cass_sogi <- raw %>%
  mutate(
    treatment              = suppressWarnings(as.integer(as.character(treatment))),
    giso_gender_identity_b = suppressWarnings(as.integer(as.character(giso_gender_identity_b))),
    giso_trans_b           = suppressWarnings(as.integer(as.character(giso_trans_b))),
    giso_sex_orient_b      = suppressWarnings(as.integer(as.character(giso_sex_orient_b)))
  ) %>%
  # >>> only youth in the intervention arm
  filter(treatment == 1L) %>%
  mutate(
    lgbtq = is_lgbtq_sogi(
      giso_gender_identity_b,
      giso_trans_b,
      giso_sex_orient_b
    )
  )

total_n <- nrow(cass_sogi)

# 1) Total number of CASSY+ in *treatment group* only
total_cassy_plus <- sum(cass_sogi$cassy_result == 1, na.rm = TRUE)

# 2) Total number of LGBTQ+ in *treatment group* only
total_lgbtq <- sum(cass_sogi$lgbtq == TRUE, na.rm = TRUE)

# 3) Among LGBTQ+ in treatment, with non-missing CASSY:
lgbtq_with_cassy <- cass_sogi %>%
  filter(lgbtq == TRUE, !is.na(cassy_result))

n_lgbtq_cassy_plus <- sum(lgbtq_with_cassy$cassy_result == 1)
n_lgbtq_not_cassy  <- sum(lgbtq_with_cassy$cassy_result != 1)

den_lgbtq_valid <- nrow(lgbtq_with_cassy)

# 4) Non-LGBTQ+ in treatment, with non-missing CASSY:
non_lgbtq_with_cassy <- cass_sogi %>%
  filter(lgbtq == FALSE, !is.na(cassy_result))

n_non_lgbtq_valid      <- nrow(non_lgbtq_with_cassy)
n_non_lgbtq_cassy_plus <- sum(non_lgbtq_with_cassy$cassy_result == 1)
n_non_lgbtq_not_cassy  <- sum(non_lgbtq_with_cassy$cassy_result != 1)

rate_non_lgbtq_cassy <- 100 * n_non_lgbtq_cassy_plus / n_non_lgbtq_valid
rate_non_lgbtq_not   <- 100 * n_non_lgbtq_not_cassy  / n_non_lgbtq_valid

# Percent of the *treatment group as a whole* that is both LGBTQ+ and CASSY+
pct_lgbtq_cassy_of_sample <- 100 * n_lgbtq_cassy_plus / total_n
pct_lgbtq_cassy_not_of_sample <- 100 * n_lgbtq_not_cassy / total_n

summary_tbl <- tibble::tribble(
  ~Metric,                                           ~N,                          ~Percent,
  "Total CASSY+ in treatment arm",                  total_cassy_plus,            100 * total_cassy_plus / total_n,
  "Total LGBTQ+ in treatment arm",                  total_lgbtq,                 100 * total_lgbtq / total_n,
  "LGBTQ+ who are CASSY+ (within LGBTQ+ w/ CASSY)", n_lgbtq_cassy_plus,          100 * n_lgbtq_cassy_plus / den_lgbtq_valid,
  "LGBTQ+ who are NOT CASSY+ (within LGBTQ+ w/ CASSY)",
                                                   n_lgbtq_not_cassy,            100 * n_lgbtq_not_cassy  / den_lgbtq_valid,
  "Non-LGBTQ+ who are CASSY+ (within non-LGBTQ+ w/ CASSY)",
                                                   n_non_lgbtq_cassy_plus,       rate_non_lgbtq_cassy,
  "Non-LGBTQ+ who are NOT CASSY+ (within non-LGBTQ+ w/ CASSY)",
                                                   n_non_lgbtq_not_cassy,        rate_non_lgbtq_not,
  "LGBTQ+ who are CASSY+ (of treatment arm)",       n_lgbtq_cassy_plus,          pct_lgbtq_cassy_of_sample,
  "LGBTQ+ who are NOT CASSY+ (of treatment arm)",   n_lgbtq_not_cassy,           pct_lgbtq_cassy_not_of_sample
)

lgbtq_cassy_simple_gt <- summary_tbl %>%
  gt::gt() %>%
  gt::fmt_number(columns = "Percent", decimals = 1) %>%
  gt::tab_header(
    title = gt::md("**CASSY+ and LGBTQ+ Summary (Treatment Arm Only)**")
  ) %>%
  gt::tab_footnote(
    footnote = "Percent for rows 3–6 is within youth with a non-missing CASSY result in that group (treatment arm only).",
    locations = gt::cells_body(rows = 3:6, columns = "Percent")
  )

lgbtq_cassy_simple_gt
```
```{r}
# ========================= CASSY+ x TREATMENT (SHOW BOTH ARMS) ======================

cass_treat_ct <- raw %>%
  mutate(
    treatment      = suppressWarnings(as.integer(as.character(treatment))),
    cassy_result   = suppressWarnings(as.integer(as.character(cassy_result))),
    Treatment_arm  = dplyr::case_when(
      treatment == 0L ~ "Control",
      treatment == 1L ~ "Treatment",
      TRUE            ~ NA_character_
    ),
    cassy_flag = dplyr::case_when(
      cassy_result == 1L                        ~ "CASSY+",
      !is.na(cassy_result) & cassy_result != 1L ~ "Not CASSY+",
      TRUE                                      ~ "Missing"
    )
  ) %>%
  # keep only youth actually in an arm
  filter(!is.na(Treatment_arm))

# Make factors so both arms & all CASSY categories show up, even if 0
cass_treat_counts <- cass_treat_ct %>%
  mutate(
    Treatment_arm = factor(Treatment_arm,
                           levels = c("Control", "Treatment")),
    cassy_flag    = factor(cassy_flag,
                           levels = c("CASSY+", "Not CASSY+", "Missing"))
  ) %>%
  count(Treatment_arm, cassy_flag, name = "N", .drop = FALSE)

cass_treat_wide <- cass_treat_counts %>%
  tidyr::pivot_wider(
    names_from  = cassy_flag,
    values_from = N,
    values_fill = 0
  ) %>%
  mutate(
    Total              = `CASSY+` + `Not CASSY+` + Missing,
    Non_missing_total  = Total - Missing,
    `CASSY+ % (non-missing)`     = ifelse(Non_missing_total > 0,
                                          100 * `CASSY+` / Non_missing_total, NA_real_),
    `Not CASSY+ % (non-missing)` = ifelse(Non_missing_total > 0,
                                          100 * `Not CASSY+` / Non_missing_total, NA_real_)
  ) %>%
  dplyr::select(
    Treatment_arm, Total, Missing,
    `CASSY+`, `CASSY+ % (non-missing)`,
    `Not CASSY+`, `Not CASSY+ % (non-missing)`
  )

cass_treat_gt <- cass_treat_wide %>%
  gt::gt() %>%
  gt::fmt_number(
    columns = c(`CASSY+ % (non-missing)`, `Not CASSY+ % (non-missing)`),
    decimals = 1
  ) %>%
  gt::tab_header(
    title = gt::md("**CASSY+ by Treatment Arm (Enrolled Youth)**")
  ) %>%
  gt::tab_footnote(
    footnote = "Percent columns use only youth with non-missing CASSY in that arm.",
    locations = gt::cells_body(
      rows = dplyr::everything(),
      columns = c(`CASSY+ % (non-missing)`, `Not CASSY+ % (non-missing)`)
    )
  )

cass_treat_gt
```

# 5) Build Tables 
```{r warning=FALSE, message=FALSE}
# ========================= TABLE BUILDERS ===================
# Outreach recode (Stata-equivalent)
recode_outreach <- function(status, sched_min, cutoff) {
  dplyr::case_when(
    status == 1 ~ 1L,
    status == 2 ~ 2L,
    status >= 3 & status <= 5 ~ 3L,
    status == 6 ~ 4L,
    status == 7 ~ 5L,
    is.na(status) & !is.na(sched_min) & sched_min < cutoff ~ 3L,
    TRUE ~ NA_integer_
  )
}

# Safe outreach counter (ensures H/K exist)
count_outreach <- function(dd, var) {
  lvls <- c(1L,2L,3L,4L,5L)
  labs <- c("Completed","Scheduled","Active","Withdrawal","Missed")
  tmp <- dd %>%
    filter(!is.na(.data[[var]])) %>%
    mutate(cat = factor(.data[[var]], levels = lvls, labels = labs)) %>%
    count(cat, site_id, name = "n") %>%
    tidyr::pivot_wider(names_from = site_id, values_from = n, values_fill = 0)
  for (nm in c("H","K")) if (!(nm %in% names(tmp))) tmp[[nm]] <- 0L
  tmp %>%
    mutate(H = coalesce(H, 0L), K = coalesce(K, 0L)) %>%
    tidyr::complete(cat = factor(labs, levels = labs), fill = list(H = 0L, K = 0L)) %>%
    arrange(cat) %>%
    mutate(Total = H + K) %>%
    rename(Item = cat)
}

# Raw follow-up visit status counter (1–7) by site
count_visitstatus <- function(dd, var) {
  lvls <- 1L:7L
  labs <- c(
    "Completed",
    "Scheduled",
    "Incomplete/Call Back",
    "Incomplete/No Contact",
    "No Show",
    "Withdrawal",
    "Missed (participant is outside date range)"
  )

  tmp <- dd %>%
    filter(!is.na(.data[[var]])) %>%
    mutate(cat = factor(as.integer(.data[[var]]),
                        levels = lvls, labels = labs)) %>%
    count(cat, site_id, name = "n") %>%
    tidyr::pivot_wider(
      names_from  = site_id,
      values_from = n,
      values_fill = 0
    )

  for (nm in c("H", "K")) if (!(nm %in% names(tmp))) tmp[[nm]] <- 0L

  tmp %>%
    mutate(
      H = coalesce(H, 0L),
      K = coalesce(K, 0L)
    ) %>%
    tidyr::complete(
      cat = factor(labs, levels = labs),
      fill = list(H = 0L, K = 0L)
    ) %>%
    arrange(cat) %>%
    mutate(Total = H + K) %>%
    rename(Item = cat)
}

# AUTO-COMPUTE TARGETS FROM PROJECTIONS USING WEEKDAYS ONLY
# ---------- Targets for CURRENT and for DATA LOCK ----------
tgt_current <- calc_targets_asof(AS_OF_DATE,  closed_interval = TRUE, round_sites = TRUE)
TARGET_H_CURR <- tgt_current$Harlem_target
TARGET_K_CURR <- tgt_current$Kings_target

tgt_lock <- calc_targets_asof(DATA_LOCK, closed_interval = TRUE, round_sites = TRUE)
TARGET_H_LOCK <- tgt_lock$Harlem_target
TARGET_K_LOCK <- tgt_lock$Kings_target

# (Optional) show both calculations
print(
  dplyr::bind_rows(
    tgt_current %>% dplyr::mutate(which = "AS_OF_DATE"),
    tgt_lock    %>% dplyr::mutate(which = "DATA_LOCK")
  ) %>%
    dplyr::select(which, as_of_date, start_date, end_date,
                  business_days_elapsed, business_days_total, fraction_elapsed,
                  Harlem_target, Kings_target, Total_target) %>%
    gt::gt() %>%
    gt::fmt_number(columns = c(fraction_elapsed), decimals = 4) %>%
    gt::tab_header(title = gt::md("**Targets (Begin-of-Month, Weekdays excl. US Holidays)**"))
)

# Build event log (3m + 6m outreach columns → long)
make_events <- function(df) {
  cols_3m <- c("follow_outreach_1_3m", paste0("follow_outreachdate_", 2:15, "_3m"))
  cols_6m <- paste0("follow_outreachdate_", 1:15, "_6m")
  mk <- function(d, cols, lab) {
    cols <- intersect(cols, names(d))
    if (!length(cols)) return(tibble(date = as.Date(character()), window = character()))
    d %>%
      select(all_of(cols)) %>%
      pivot_longer(everything(), names_to = "var", values_to = "raw") %>%
      mutate(date = as_date_guess(raw), window = lab) %>%
      filter(!is.na(date))
  }
  bind_rows(
    mk(df, cols_3m, "3m"),
    mk(df, cols_6m, "6m")
  ) %>% mutate(window = factor(window, levels = c("3m","6m")))
}

pad_windows <- function(df) {
  if (!("3m" %in% names(df))) df[["3m"]] <- 0L
  if (!("6m" %in% names(df))) df[["6m"]] <- 0L
  df
}

daily_table_for_week <- function(events, any_date, label) {
  week_mon <- floor_date(as.Date(any_date), "week", week_start = 1)
  days_mf  <- tibble(date = seq.Date(week_mon, week_mon + days(6), by = "day")) %>%
    filter(wday(date, week_start = 1) <= 5)
  day_counts <- events %>%
    filter(date >= week_mon, date <= week_mon + days(6)) %>%
    count(date, window, name = "n") %>%
    pivot_wider(names_from = window, values_from = n, values_fill = 0)
  wid <- left_join(days_mf, day_counts, by = "date") %>%
    pad_windows() %>%
    transmute(
      date,
      `3 months` = as.integer(`3m`),
      `6 months` = as.integer(`6m`),
      Total      = `3 months` + `6 months`
    ) %>%
    arrange(date)
  gt(wid) %>%
    tab_header(
      title = md(paste0(
        "**Number of Outreaches per Day**<br>",
        "<span style='font-size:12px'>", label,
        " — Week of ", format(week_mon, "%m/%d/%Y"), "</span>"
      ))
    ) %>%
    fmt_date(columns = date, date_style = 3) %>%
    summary_rows(groups = NULL,
                 columns = c(`3 months`,`6 months`, Total),
                 fns = list(`Weekly Total` = ~sum(.x, na.rm = TRUE))) %>%
    cols_label(date = "Date") %>%
    fmt_number(columns = c(`3 months`, `6 months`, Total), decimals = 0)
}

build_all <- function(df,
                      as_of_date,
                      target_H, target_K,
                      weeks_input,
                      cutoff_3m = CUTOFF_3M,
                      cutoff_6m = CUTOFF_6M,
                      label = "Current data",
                      want_enroll = TRUE,
                      want_fu     = TRUE,
                      want_weekly = TRUE,
                      want_daily  = TRUE,
                      want_enroll_weekly = TRUE) {

  out <- list()

  # ----- ENROLLMENT -----
  if (want_enroll) {
    approached     <- df %>% distinct(record_id, site_id) %>% count_by_site()
    enrolled_total <- count_by_site(df, !is.na(treatment))
    enrolled_ctrl  <- count_by_site(df, treatment == 0)
    enrolled_tx    <- count_by_site(df, treatment == 1)
    cassy_plus     <- count_by_site(df, treatment == 1 & cassy_result == 1)

    target_row <- tibble(Harlem = target_H, Kings = target_K) %>% mutate(Total = Harlem + Kings)

    enroll_tbl <- bind_rows(
      tibble(Item = "Total approached") %>% bind_cols(approached),
      tibble(Item = paste0("Target enrollment (as of ", format(as_of_date, "%m/%d"), ")")) %>% bind_cols(target_row),
      tibble(Item = "Total enrollment")              %>% bind_cols(enrolled_total),
      tibble(Item = "Total Control Group")           %>% bind_cols(enrolled_ctrl),
      tibble(Item = "Total Intervention Group")      %>% bind_cols(enrolled_tx),
      tibble(Item = "Total CASSY+/CFS Intervention") %>% bind_cols(cassy_plus)
    )

    out$enroll_gt <- enroll_tbl %>%
      gt(rowname_col = "Item") %>%
      tab_header(
        title    = md("**WeCare Youth Enrollment**"),
        subtitle = md(paste0(label, " — as of ", format(as_of_date, "%m/%d/%Y")))
      ) %>%
      cols_label(Harlem = "Harlem", Kings = "Kings", Total = "Total") %>%
      fmt_number(columns = c(Harlem, Kings, Total), decimals = 0)
  }

  # ----- FOLLOW-UP OUTREACH SUMMARY (3m & 6m) -----
    # ----- FOLLOW-UP OUTREACH SUMMARY (3m & 6m) -----
  if (want_fu) {
    # First: clean raw visit status + scheduled dates
    dat_fu_status <- df %>%
      mutate(
        follow_visitstatus_3m = suppressWarnings(as.integer(as.character(follow_visitstatus_3m))),
        follow_visitstatus_6m = suppressWarnings(as.integer(as.character(follow_visitstatus_6m))),
        follow_sch_min_3m     = as_date_guess(follow_sch_min_3m),
        follow_sch_min_6m     = as_date_guess(follow_sch_min_6m)
      )

    # ---------- NEW: raw visit status tables (1–7) ----------
    fu3_status_tbl <- count_visitstatus(dat_fu_status, "follow_visitstatus_3m")
    fu6_status_tbl <- count_visitstatus(dat_fu_status, "follow_visitstatus_6m")

    out$fu3_status_gt <- fu3_status_tbl %>%
      gt(rowname_col = "Item") %>%
      tab_header(
        title = md(paste0(
          "**WeCare Follow-Up Visit Status**<br>",
          "<span style='font-size:12px'>3-month — ", label, "</span>"
        ))
      ) %>%
      cols_label(H = "Harlem", K = "Kings", Total = "Total") %>%
      fmt_number(columns = c(H, K, Total), decimals = 0)

    out$fu6_status_gt <- fu6_status_tbl %>%
      gt(rowname_col = "Item") %>%
      tab_header(
        title = md(paste0(
          "**WeCare Follow-Up Visit Status**<br>",
          "<span style='font-size:12px'>6-month — ", label, "</span>"
        ))
      ) %>%
      cols_label(H = "Harlem", K = "Kings", Total = "Total") %>%
      fmt_number(columns = c(H, K, Total), decimals = 0)

    # ---------- Then: outreach recode using those cleaned vars ----------
    dat_fu <- dat_fu_status %>%
      mutate(
        outreach_3m = recode_outreach(follow_visitstatus_3m, follow_sch_min_3m, cutoff_3m),
        outreach_6m = recode_outreach(follow_visitstatus_6m, follow_sch_min_6m, cutoff_6m)
      )

    fu3_tbl <- count_outreach(dat_fu, "outreach_3m")
    fu6_tbl <- count_outreach(dat_fu, "outreach_6m")

    out$fu3_gt <- fu3_tbl %>%
      gt(rowname_col = "Item") %>%
      tab_header(title = md(paste0(
        "**WeCare Follow-Up Assessments**<br>",
        "<span style='font-size:12px'>3-month — ", label, "</span>"
      ))) %>%
      cols_label(H = "Harlem", K = "Kings", Total = "Total") %>%
      fmt_number(columns = c(H, K, Total), decimals = 0)

    out$fu6_gt <- fu6_tbl %>%
      gt(rowname_col = "Item") %>%
      tab_header(title = md(paste0(
        "**WeCare Follow-Up Assessments**<br>",
        "<span style='font-size:12px'>6-month — ", label, "</span>"
      ))) %>%
      cols_label(H = "Harlem", K = "Kings", Total = "Total") %>%
      fmt_number(columns = c(H, K, Total), decimals = 0)
  }

  # ----- OUTREACHES PER WEEK / PER DAY -----
  if (want_weekly || want_daily) {
    events <- make_events(df)

    if (want_weekly) {
      weekly_rows <- lapply(weeks_input, function(w) {
        week_mon <- floor_date(as.Date(w), "week", week_start = 1)
        cnt <- events %>%
          filter(date >= week_mon, date <= week_mon + days(6)) %>%
          count(window, name = "n") %>%
          pivot_wider(names_from = window, values_from = n, values_fill = 0) %>%
          pad_windows()
        if (nrow(cnt) == 0) {
          tibble(`Week of:` = format(week_mon, "%m/%d/%Y"),
                 `3 months` = 0L, `6 months` = 0L, Total = 0L)
        } else {
          cnt %>% transmute(
            `Week of:` = format(week_mon, "%m/%d/%Y"),
            `3 months` = as.integer(`3m`),
            `6 months` = as.integer(`6m`),
            Total      = `3 months` + `6 months`
          )
        }
      }) |> bind_rows() |>
        arrange(desc(as.Date(`Week of:`, format = "%m/%d/%Y")))

      out$weekly_gt <- gt(weekly_rows) %>%
        tab_header(title = md(paste0("**Number of Outreaches per Week**<br>",
                                     "<span style='font-size:12px'>", label, "</span>"))) %>%
        fmt_number(columns = c(`3 months`, `6 months`, Total), decimals = 0)
    }

    if (want_daily) {
      out$daily_gts <- lapply(weeks_input, function(w) daily_table_for_week(events, w, label))
    }
  }
  
    # ----- WEEKLY ENROLLMENT (Actuals vs Target) -----
  if (want_enroll_weekly) {
    out$weekly_enroll_gt <- weekly_enrollment_table(
      df          = df,
      weeks_input = weeks_input,
      as_of_date  = as_of_date,
      label       = label
    )
  }

  out
}
```

# Table Output 
```{r warning=FALSE, message=FALSE, echo=FALSE}
# ========================= RUN BUILDS =======================

# Helper that ALWAYS emits a gt table
emit_gt <- function(x) {
  if (inherits(x, "gt_tbl")) {
    print(x)            # let gt/knitr handle the HTML
  }
}

# (Optional) show the targets comparison table first
if (exists("targets_gt")) emit_gt(targets_gt)

if (RUN_CURRENT) {
  current <- build_all(
    df          = raw,
    as_of_date  = AS_OF_DATE,
    target_H    = TARGET_H_CURR,
    target_K    = TARGET_K_CURR,
    weeks_input = WEEKS_INPUT,
    label       = "Current data",
    want_enroll = SHOW_ENROLL,
    want_fu     = SHOW_FOLLOWUP,
    want_weekly = SHOW_OUTREACH_WEEKLY,
    want_daily  = SHOW_OUTREACH_DAILY,
    want_enroll_weekly = SHOW_ENROLL_WEEKLY
  )

  if (SHOW_ENROLL) emit_gt(current$enroll_gt)

  if (SHOW_FOLLOWUP) {
    # NEW: raw visit-status tables (1–7) by site
    emit_gt(current$fu3_status_gt)
    emit_gt(current$fu6_status_gt)

    # Existing: recoded outreach tables
    emit_gt(current$fu3_gt)
    emit_gt(current$fu6_gt)
  }

  if (SHOW_OUTREACH_WEEKLY) emit_gt(current$weekly_gt)
  if (SHOW_ENROLL_WEEKLY)   emit_gt(current$weekly_enroll_gt)
  if (SHOW_OUTREACH_DAILY)  for (g in current$daily_gts) emit_gt(g)
}

if (RUN_LOCKED) {
  weeks_for_lock <- WEEKS_INPUT[WEEKS_INPUT <= DATA_LOCK]

  locked <- build_all(
    df          = locked_df,
    as_of_date  = DATA_LOCK,
    target_H    = TARGET_H_LOCK,
    target_K    = TARGET_K_LOCK,
    weeks_input = if (length(weeks_for_lock)) weeks_for_lock else WEEKS_INPUT,
    label       = paste0("Data locked < ", format(DATA_LOCK, "%m/%d/%Y")),
    want_enroll = SHOW_ENROLL,
    want_fu     = SHOW_FOLLOWUP,
    want_weekly = SHOW_OUTREACH_WEEKLY,
    want_daily  = SHOW_OUTREACH_DAILY,
    want_enroll_weekly = SHOW_ENROLL_WEEKLY
  )

  if (SHOW_ENROLL) emit_gt(locked$enroll_gt)

  if (SHOW_FOLLOWUP) {
    # NEW: raw visit-status tables (1–7) by site
    emit_gt(locked$fu3_status_gt)
    emit_gt(locked$fu6_status_gt)

    # Existing: recoded outreach tables
    emit_gt(locked$fu3_gt)
    emit_gt(locked$fu6_gt)
  }

  if (SHOW_OUTREACH_WEEKLY) emit_gt(locked$weekly_gt)
  if (SHOW_ENROLL_WEEKLY)   emit_gt(locked$weekly_enroll_gt)
  if (SHOW_OUTREACH_DAILY)  for (g in locked$daily_gts) emit_gt(g)
}
```

```{r}
library(dplyr)
library(lubridate)

# Raw variable name -> stakeholder-friendly column name
name_map <- c(
  record_id               = "Record ID",
  merged_date             = "Merged date",
  first_name              = "First name",
  last_name               = "Last name",
  screen_age              = "Screen age",
  treatment               = "Treatment",
  cassy_result            = "CASSY result",
  swdf_received_cfs       = "Did this participant receive CFS?",
  swdf_received_cfs_texts = "Upload to Meditext for supportive texts?",
  screen_has_cell_phone   = "Has a cell phone that receives texts?",
  swdf_phone_primary      = "Youth phone (primary)",
  swdf_phone_alternate    = "Youth phone (alternate)",
  swdf_phone_reenter      = "Youth phone (re-enter)",
  swdf_p_phone_primary    = "Parent phone (primary)",
  swdf_p_understand_eng   = "Parent understands English?"
)

jan_enrolled_cfs_check <- raw %>%
  mutate(
    merged_date = to_date_smart(merged_date),
    jan_2026 = merged_date >= as.Date("2026-01-01") & merged_date <= as.Date("2026-01-31"),
    enrolled = !is.na(treatment),
    swdf_received_cfs = as.character(swdf_received_cfs)  # normalize
  ) %>%
  filter(jan_2026, enrolled) %>%
  mutate(
    swdf_received_cfs_clean = case_when(
      swdf_received_cfs %in% c("1", 1) ~ "1",
      swdf_received_cfs %in% c("0", 0) ~ "0",
      is.na(swdf_received_cfs) | swdf_received_cfs == "" ~ "NA",
      TRUE ~ paste0("OTHER:", swdf_received_cfs)
    )
  ) %>%
  select(
    record_id, 
    merged_date, 
    # first_name, 
    # last_name, 
    screen_age,
    treatment,
    cassy_result,
    swdf_received_cfs,         # keep raw for sorting + mapping
    swdf_received_cfs_texts,
    screen_has_cell_phone,
    swdf_phone_primary,
    swdf_phone_alternate,
    # swdf_phone_reenter,
    swdf_p_phone_primary,
    swdf_p_understand_eng
  ) %>%
  # Sort by swdf_received_cfs (0 first, then 1, then NA/other), then cassy_result, then treatment, then date/id
  mutate(
    swdf_received_cfs_sort = case_when(
      swdf_received_cfs %in% c("0", 0) ~ 0L,
      swdf_received_cfs %in% c("1", 1) ~ 1L,
      TRUE ~ 2L
    )
  ) %>%
  arrange(swdf_received_cfs_sort, cassy_result, treatment, merged_date, record_id) %>%
  select(-swdf_received_cfs_sort) %>%
  rename(any_of(name_map))

jan_enrolled_cfs_check
```



```{r}
library(dplyr)
library(lubridate)

# Raw variable name -> stakeholder-friendly column name
name_map <- c(
  record_id               = "Record ID",
  merged_date             = "Merged date",
  first_name              = "First name",
  last_name               = "Last name",
  screen_age              = "Screen age",
  treatment               = "Treatment",
  cassy_result            = "CASSY result",
  swdf_received_cfs       = "Did this participant receive CFS?",
  swdf_received_cfs_texts = "Upload to Meditext for supportive texts?",
  screen_has_cell_phone   = "Has a cell phone that receives texts?",
  swdf_phone_primary      = "Youth phone (primary)",
  swdf_phone_alternate    = "Youth phone (alternate)",
  swdf_phone_reenter      = "Youth phone (re-enter)",
  swdf_p_phone_primary    = "Parent phone (primary)",
  swdf_p_understand_eng   = "Parent understands English?"
)

# IDs from Cheryl's email (ONLY these)
ids_focus <- c(
  "K-F0686","K-F0664","K-F0654","K-F0653","K-F0623","K-F0636",
  "K-F0601","K-F0613","K-F0610","K-F0596","K-F0587"
)

cfs_check_ids_only <- raw %>%
  mutate(
    merged_date = to_date_smart(merged_date),
    swdf_received_cfs = as.character(swdf_received_cfs)  # normalize
  ) %>%
  filter(record_id %in% ids_focus) %>%
  mutate(
    swdf_received_cfs_clean = case_when(
      swdf_received_cfs %in% c("1", 1) ~ "1",
      swdf_received_cfs %in% c("0", 0) ~ "0",
      is.na(swdf_received_cfs) | swdf_received_cfs == "" ~ "NA",
      TRUE ~ paste0("OTHER:", swdf_received_cfs)
    )
  ) %>%
  select(
    record_id,
    merged_date,
    # first_name,
    # last_name,
    screen_age,
    treatment,
    cassy_result,
    swdf_received_cfs,         # keep raw for sorting + mapping
    swdf_received_cfs_texts,
    screen_has_cell_phone,
    swdf_phone_primary,
    swdf_phone_alternate,
    # swdf_phone_reenter,
    swdf_p_phone_primary,
    swdf_p_understand_eng
  ) %>%
  mutate(
    swdf_received_cfs_sort = case_when(
      swdf_received_cfs %in% c("0", 0) ~ 0L,
      swdf_received_cfs %in% c("1", 1) ~ 1L,
      TRUE ~ 2L
    )
  ) %>%
  arrange(swdf_received_cfs_sort, cassy_result, treatment, merged_date, record_id) %>%
  select(-swdf_received_cfs_sort) %>%
  rename(any_of(name_map))

cfs_check_ids_only
```








```{r}
# ========================= FOLLOW-UP RATE INCREASE (3m vs 6m) =========================

# ---- period definitions ----
period_labels <- tibble::tribble(
  ~period_code, ~period_label,                ~start,                 ~end,
  "pre",        "Pre 08/01/2025",             as.Date("1900-01-01"),  as.Date("2025-08-01"),
  "post",       "08/01/2025–01/01/2026",      as.Date("2025-08-01"),  as.Date("2026-01-01")
)

# ---- sanity checks for required columns ----
need_cols <- c(
  "record_id", "treatment",
  "follow_visitdate_3m", "follow_visitdate_6m",
  "follow_visitstatus_3m", "follow_visitstatus_6m"
)
missing <- setdiff(need_cols, names(raw))
if (length(missing)) stop("Missing required columns: ", paste(missing, collapse = ", "))

# ---- clean + parse follow-up scheduling/completion fields ----
fu <- raw %>%
  mutate(
    record_id = as.character(record_id),
    treatment = suppressWarnings(as.integer(as.character(treatment))),

    # Parse visitdates robustly (THIS is what usually fixes the “all 0s”)
    vd_3m = to_date_smart(follow_visitdate_3m),
    vd_6m = to_date_smart(follow_visitdate_6m),

    vs_3m = suppressWarnings(as.integer(as.character(follow_visitstatus_3m))),
    vs_6m = suppressWarnings(as.integer(as.character(follow_visitstatus_6m)))
  ) %>%
  filter(!is.na(treatment))  # enrolled participants only (matches your 453 denom)

n_participants <- dplyr::n_distinct(fu$record_id)

# ---- DEBUG: if these are ~0, your visitdate fields aren’t parsing ----
debug_visitdates <- fu %>%
  summarise(
    n_participants = n_participants,
    nonmissing_vd_3m = sum(!is.na(vd_3m)),
    nonmissing_vd_6m = sum(!is.na(vd_6m)),
    min_vd_3m = suppressWarnings(min(vd_3m, na.rm = TRUE)),
    max_vd_3m = suppressWarnings(max(vd_3m, na.rm = TRUE)),
    min_vd_6m = suppressWarnings(min(vd_6m, na.rm = TRUE)),
    max_vd_6m = suppressWarnings(max(vd_6m, na.rm = TRUE))
  )
print(debug_visitdates)

# If min/max show Inf or nonmissing_vd_* are 0, print some raw examples:
if (sum(!is.na(fu$vd_3m)) == 0) {
  cat("\nExamples of raw follow_visitdate_3m values (first 30 non-blank):\n")
  print(head(raw$follow_visitdate_3m[raw$follow_visitdate_3m != ""], 30))
}
if (sum(!is.na(fu$vd_6m)) == 0) {
  cat("\nExamples of raw follow_visitdate_6m values (first 30 non-blank):\n")
  print(head(raw$follow_visitdate_6m[raw$follow_visitdate_6m != ""], 30))
}

# ---- long form for scheduled/completed counting (avoid pivoting mixed types) ----
schedcomp_long <- dplyr::bind_rows(
  fu %>% transmute(window = "3m", record_id, visitdate = vd_3m, status = vs_3m),
  fu %>% transmute(window = "6m", record_id, visitdate = vd_6m, status = vs_6m)
) %>%
  mutate(
    period_code = dplyr::case_when(
      !is.na(visitdate) & visitdate <  as.Date("2025-08-01") ~ "pre",
      !is.na(visitdate) & visitdate >= as.Date("2025-08-01") & visitdate < as.Date("2026-01-01") ~ "post",
      TRUE ~ NA_character_
    )
  )

schedcomp_metrics <- schedcomp_long %>%
  filter(!is.na(period_code)) %>%
  group_by(window, period_code) %>%
  summarise(
    n_scheduled = dplyr::n_distinct(record_id), # visitdate present in period
    n_completed = dplyr::n_distinct(record_id[!is.na(status) & status == 1L]), # status==1 and dated (already filtered by visitdate)
    .groups = "drop"
  ) %>%
  right_join(tidyr::crossing(window = c("3m","6m"), period_labels %>% select(period_code)),
             by = c("window","period_code")) %>%
  mutate(
    n_scheduled = dplyr::coalesce(n_scheduled, 0L),
    n_completed = dplyr::coalesce(n_completed, 0L)
  ) %>%
  left_join(period_labels %>% select(period_code, period_label), by = "period_code")

# ---- outreach events WITH participant ids ----
make_events_pid <- function(df) {
  cols_3m <- c("follow_outreach_1_3m", paste0("follow_outreachdate_", 2:15, "_3m"))
  cols_6m <- paste0("follow_outreachdate_", 1:15, "_6m")

  mk <- function(d, cols, lab) {
    cols <- intersect(cols, names(d))
    if (!length(cols)) return(tibble(record_id = character(), date = as.Date(character()), window = character()))
    d %>%
      transmute(record_id = as.character(record_id)) %>%
      bind_cols(d %>% select(all_of(cols))) %>%
      pivot_longer(cols = all_of(cols), names_to = "var", values_to = "raw") %>%
      mutate(date = as_date_guess(raw), window = lab) %>%
      filter(!is.na(date)) %>%
      select(record_id, date, window)
  }

  bind_rows(
    mk(df, cols_3m, "3m"),
    mk(df, cols_6m, "6m")
  )
}

events_pid <- make_events_pid(fu)

events_pid <- events_pid %>%
  mutate(
    period_code = dplyr::case_when(
      date <  as.Date("2025-08-01") ~ "pre",
      date >= as.Date("2025-08-01") & date < as.Date("2026-01-01") ~ "post",
      TRUE ~ NA_character_
    )
  ) %>%
  filter(!is.na(period_code))

outreach_metrics <- events_pid %>%
  group_by(window, period_code) %>%
  summarise(outreach_attempts = dplyr::n(), .groups = "drop") %>%
  right_join(
    tidyr::crossing(window = c("3m", "6m"), period_labels %>% select(period_code, period_label)),
    by = c("window", "period_code")
  ) %>%
  mutate(outreach_attempts = dplyr::coalesce(outreach_attempts, 0L)) %>%
  select(window, period_code, period_label, outreach_attempts)

# ---- final table ----
final_tbl <- schedcomp_metrics %>%
  select(window, period_code, period_label, n_scheduled, n_completed) %>%
  left_join(outreach_metrics, by = c("window","period_code","period_label")) %>%
  mutate(
    n_participants = n_participants,
    sched_per_participant    = n_scheduled / n_participants,
    comp_per_participant     = n_completed / n_participants,
    outreach_per_participant = outreach_attempts / n_participants
  ) %>%
  select(
    Window = window,
    Period = period_label,
    `N participants (denom)` = n_participants,
    `N scheduled (visitdate present)` = n_scheduled,
    `Scheduled / participant` = sched_per_participant,
    `N completed (status==1, dated)` = n_completed,
    `Completed / participant` = comp_per_participant,
    `Outreach attempts (dated)` = outreach_attempts,
    `Outreach / participant` = outreach_per_participant
  ) %>%
  arrange(Window, desc(Period))

gt::gt(final_tbl) %>%
  gt::fmt_number(
    columns = c(`Scheduled / participant`, `Completed / participant`, `Outreach / participant`),
    decimals = 4
  ) %>%
  gt::fmt_number(
    columns = c(`N participants (denom)`, `N scheduled (visitdate present)`, `N completed (status==1, dated)`, `Outreach attempts (dated)`),
    decimals = 0
  ) %>%
  gt::tab_header(title = gt::md("**Follow-up scheduling, completion, and outreach attempts per participant**"))
```
```{r}
# ========================= % CHANGE SUMMARY (COUNTS ONLY) =========================
# Assumes you already created final_tbl

pct_change_counts_tbl <- final_tbl %>%
  transmute(
    window = Window,
    period = Period,

    n_scheduled = `N scheduled (visitdate present)`,
    n_completed = `N completed (status==1, dated)`,
    outreach_attempts = `Outreach attempts (dated)`
  ) %>%
  mutate(
    period_code = dplyr::case_when(
      stringr::str_detect(period, "^Pre") ~ "pre",
      TRUE ~ "post"
    )
  ) %>%
  select(-period) %>%
  tidyr::pivot_wider(
    names_from  = period_code,
    values_from = c(n_scheduled, n_completed, outreach_attempts)
  ) %>%
  mutate(
    # ratios + % change (guard against divide-by-zero)
    sched_ratio = ifelse(n_scheduled_pre > 0, n_scheduled_post / n_scheduled_pre, NA_real_),
    comp_ratio  = ifelse(n_completed_pre > 0, n_completed_post / n_completed_pre, NA_real_),
    out_ratio   = ifelse(outreach_attempts_pre > 0, outreach_attempts_post / outreach_attempts_pre, NA_real_),

    sched_pct_change = 100 * (sched_ratio - 1),
    comp_pct_change  = 100 * (comp_ratio  - 1),
    out_pct_change   = 100 * (out_ratio   - 1)
  ) %>%
  transmute(
    Window = window,

    `Scheduled (Pre)`  = n_scheduled_pre,
    `Scheduled (Post)` = n_scheduled_post,
    `Scheduled % change` = sched_pct_change,

    `Completed (Pre)`  = n_completed_pre,
    `Completed (Post)` = n_completed_post,
    `Completed % change` = comp_pct_change,

    `Outreach attempts (Pre)`  = outreach_attempts_pre,
    `Outreach attempts (Post)` = outreach_attempts_post,
    `Outreach % change` = out_pct_change
  ) %>%
  arrange(Window)

gt::gt(pct_change_counts_tbl) %>%
  gt::tab_header(title = gt::md("**% Change (Counts Only): 08/01/2025–01/01/2026 vs Pre 08/01/2025**")) %>%
  gt::fmt_number(
    columns = c(
      `Scheduled (Pre)`, `Scheduled (Post)`,
      `Completed (Pre)`, `Completed (Post)`,
      `Outreach attempts (Pre)`, `Outreach attempts (Post)`
    ),
    decimals = 0
  ) %>%
  gt::fmt_number(
    columns = c(`Scheduled % change`, `Completed % change`, `Outreach % change`),
    decimals = 1
  )
```
# Follow Up Rate Tables 
```{r asof_flags}

# ---- CSSR item -> risk flags (mutually exclusive: high first, then med) ----
to_01 <- function(x) {
  x <- suppressWarnings(as.integer(as.character(x)))
  dplyr::case_when(
    is.na(x) ~ NA_integer_,
    x == 1L  ~ 1L,
    x == 0L  ~ 0L,
    TRUE     ~ NA_integer_
  )
}

derive_cssr_risk_flags <- function(dat) {

  # helper: safe column fetch that returns all-NA vector if missing
  get_col <- function(nm) {
    if (nm %in% names(dat)) dat[[nm]] else rep(NA, nrow(dat))
  }

  dat %>%
    mutate(
      # ===== BASELINE (your item list) =====
      cssr_high_b = as.integer(
        to_01(get_col("cssrs_4a_b")) == 1L |
        to_01(get_col("cssrs_5a_b")) == 1L |
        to_01(get_col("cssrs_7b_b")) == 1L
      ),
      cssr_med_b_raw = as.integer(
        to_01(get_col("cssrs_3a_b")) == 1L |
        to_01(get_col("cssrs_7a_b")) == 1L
      ),
      cssr_med_b = as.integer(cssr_high_b == 0L & cssr_med_b_raw == 1L),

      # ===== 3 MONTH (your item list) =====
      cssr_high_3m = as.integer(
        to_01(get_col("cssrs_4_3m")) == 1L |
        to_01(get_col("cssrs_5_3m")) == 1L |
        to_01(get_col("cssrs_7_3m")) == 1L
      ),
      cssr_med_3m_raw = as.integer(to_01(get_col("cssrs_3_3m")) == 1L),
      cssr_med_3m = as.integer(cssr_high_3m == 0L & cssr_med_3m_raw == 1L),

      # ===== 6 MONTH (ONLY if those columns exist; otherwise stays NA) =====
      cssr_high_6m = as.integer(
        to_01(get_col("cssrs_4_6m")) == 1L |
        to_01(get_col("cssrs_5_6m")) == 1L |
        to_01(get_col("cssrs_7_6m")) == 1L
      ),
      cssr_med_6m_raw = as.integer(to_01(get_col("cssrs_3_6m")) == 1L),
      cssr_med_6m = as.integer(cssr_high_6m == 0L & cssr_med_6m_raw == 1L)
    ) %>%
    select(-cssr_med_b_raw, -cssr_med_3m_raw, -cssr_med_6m_raw)
}

raw <- derive_cssr_risk_flags(raw)

ASOF_DATES <- as.Date(c("2025-08-01", "2026-01-01"))

prep_asof <- function(df, lock_date) {

  parsed <- df %>%
    mutate(
      # ---- lock basis date (row included only if merged before lock) ----
      merged_date_parsed = to_date_smart(merged_date),

      # ---- follow-up dates (for as-of counting) ----
      fu3m_date_parsed = to_date_smart(follow_visitdate_3m),
      fu6m_date_parsed = to_date_smart(follow_visitdate_6m),

      # raw status flags
      fu3m_status = suppressWarnings(as.integer(as.character(follow_visitstatus_3m))) == 1L,
      fu6m_status = suppressWarnings(as.integer(as.character(follow_visitstatus_6m))) == 1L,

      # ---- as-of completed = status==1 AND date exists and is before lock_date ----
      fu3m_completed = fu3m_status & !is.na(fu3m_date_parsed) & fu3m_date_parsed < lock_date,
      fu6m_completed = fu6m_status & !is.na(fu6m_date_parsed) & fu6m_date_parsed < lock_date,

      # baseline sample definition
      treatment_int  = suppressWarnings(as.integer(as.character(treatment)))
    )

  # ---- audit counts (optional but helpful) ----
  n_total <- nrow(parsed)
  n_bad_merged <- sum(is.na(parsed$merged_date_parsed))
  n_after_merged_lock <- sum(!is.na(parsed$merged_date_parsed) & parsed$merged_date_parsed >= lock_date)

  n_fu3_status_on <- sum(parsed$fu3m_status, na.rm = TRUE)
  n_fu3_counted   <- sum(parsed$fu3m_completed, na.rm = TRUE)

  n_fu6_status_on <- sum(parsed$fu6m_status, na.rm = TRUE)
  n_fu6_counted   <- sum(parsed$fu6m_completed, na.rm = TRUE)

  out <- parsed %>%
  filter(!is.na(merged_date_parsed), merged_date_parsed < lock_date) %>%
  filter(!is.na(treatment_int)) %>%
  mutate(
    # cssr_pos_b can now be computed because cssr_high_b/cssr_med_b exist
    cssr_pos_b = case_when(
      cssr_high_b == 1L ~ TRUE,
      cssr_high_b == 0L & cssr_med_b == 1L ~ TRUE,
      cssr_high_b == 0L & cssr_med_b == 0L ~ FALSE,
      TRUE ~ NA
    ),
    cassy_pos_b = cassy_result == 1L   # per your rule: use cassy_result
  )

  cat("\nAS-OF LOCK:", format(lock_date), "\n")
  cat("Rows total:", n_total, "\n")
  cat("Rows with unparsed merged_date:", n_bad_merged, "\n")
  cat("Rows with merged_date >= lock_date (dropped):", n_after_merged_lock, "\n")
  cat("Rows kept after merged_date lock + treatment filter:", nrow(out), "\n")
  cat("3m status==1:", n_fu3_status_on, " | 3m counted (status==1 & date<lock):", n_fu3_counted, "\n")
  cat("6m status==1:", n_fu6_status_on, " | 6m counted (status==1 & date<lock):", n_fu6_counted, "\n\n")

  out
}
```
---

# 2) Table: 3m, 6m, and “either” follow-up completion rates (as of Jan 1)

```{r table_fu_rates_asof}
summ_fu_rates <- function(dat, asof_date) {
  tibble::tibble(
    `As of` = format(asof_date, "%Y-%m-%d"),
    N_baseline = dplyr::n_distinct(dat$record_id),
    `3m completed (n)` = sum(dat$fu3m_completed, na.rm = TRUE),
    `3m completed (%)` = mean(dat$fu3m_completed, na.rm = TRUE) * 100,
    `6m completed (n)` = sum(dat$fu6m_completed, na.rm = TRUE),
    `6m completed (%)` = mean(dat$fu6m_completed, na.rm = TRUE) * 100,
    `Either 3m or 6m completed (n)` = sum(dat$fu3m_completed | dat$fu6m_completed, na.rm = TRUE),
    `Either 3m or 6m completed (%)` = mean(dat$fu3m_completed | dat$fu6m_completed, na.rm = TRUE) * 100
  )
}

df_asof_aug <- prep_asof(df, as.Date("2025-08-01"))
df_asof_jan <- prep_asof(df, as.Date("2026-01-01"))

fu_rates_compare <- dplyr::bind_rows(
  summ_fu_rates(df_asof_aug, as.Date("2025-08-01")),
  summ_fu_rates(df_asof_jan, as.Date("2026-01-01"))
)

# Optional: add change row (Jan - Aug)
delta_row <- fu_rates_compare %>%
  dplyr::summarise(
    `As of` = "Δ",
    dplyr::across(where(is.numeric), ~ .[2] - .[1])
  )

fu_rates_compare <- dplyr::bind_rows(fu_rates_compare, delta_row)

gt::gt(fu_rates_compare) %>%
  gt::fmt_number(columns = ends_with("(%)"), decimals = 1) %>%
  gt::fmt_number(columns = c("N_baseline", ends_with("(n)")), decimals = 0) %>%
  gt::tab_header(
    title = "Follow-up completion rates: Aug 1, 2025 vs Jan 1, 2026 (as-of snapshots)"
  ) %>%
  gt::tab_source_note(
    "Each 'as of' snapshot keeps participants with merged_date < the as-of date, and baseline requires treatment not NA. Δ row is Jan - Aug."
  )
```
```{r eligibility_flags}
# Uses the same date parser behavior as prep_asof (timestamps OK)
parse_date_any_safe <- function(x) {
  x <- as.character(x)
  dplyr::coalesce(
    suppressWarnings(as.Date(x)),
    suppressWarnings(as.Date(x, format = "%m/%d/%Y")),
    suppressWarnings(as.Date(x, format = "%m/%d/%y")),
    suppressWarnings(as.Date(x, format = "%Y/%m/%d")),
    suppressWarnings(as.Date(substr(x, 1, 10)))
  )
}

add_eligibility_flags <- function(dat, lock_date) {
  dat %>%
    mutate(
      # schedule windows
      sch_min_3m = to_date_smart(follow_sch_min_3m),
      sch_max_3m = to_date_smart(follow_sch_max_3m),
      sch_min_6m = to_date_smart(follow_sch_min_6m),
      sch_max_6m = to_date_smart(follow_sch_max_6m),

      has_sched_3m = !is.na(sch_min_3m) & !is.na(sch_max_3m),
      has_sched_6m = !is.na(sch_min_6m) & !is.na(sch_max_6m),

      # Denominator 1: window ever opened by lock date
      elig_3m_ever_open = has_sched_3m & (sch_min_3m <= lock_date),
      elig_6m_ever_open = has_sched_6m & (sch_min_6m <= lock_date),

      # Denominator 2: window closed by lock date
      # If you consider max date inclusive, this is correct:
      elig_3m_closed = has_sched_3m & (sch_max_3m <= lock_date),
      elig_6m_closed = has_sched_6m & (sch_max_6m <= lock_date),

      # Optional (not requested, but sometimes useful): currently open at lock
      open_3m_now = has_sched_3m & lock_date >= sch_min_3m & lock_date <= sch_max_3m,
      open_6m_now = has_sched_6m & lock_date >= sch_min_6m & lock_date <= sch_max_6m
    )
}

```

## 2) Drop-in: build the “ever opened” and “closed” rate tables (Aug vs Jan)

This produces **two GT tables**:
- Table A: completion among those whose window **ever opened**
- Table B: completion among those whose window is **closed**

```{r fu_rate_tables_open_vs_closed}
summ_rates <- function(dat, lock_date, denom_type = c("ever_open", "closed")) {
  denom_type <- match.arg(denom_type)

  # choose eligibility flags
  if (denom_type == "ever_open") {
    e3 <- dat$elig_3m_ever_open
    e6 <- dat$elig_6m_ever_open
    denom_label <- "Window ever opened"
  } else {
    e3 <- dat$elig_3m_closed
    e6 <- dat$elig_6m_closed
    denom_label <- "Window closed"
  }

  # denominators
  d3 <- sum(dplyr::coalesce(e3, FALSE))
  d6 <- sum(dplyr::coalesce(e6, FALSE))
  de <- sum(dplyr::coalesce(e3 | e6, FALSE))  # eligible for either wave

  # numerators: completed by lock AND eligible
  n3 <- sum(dplyr::coalesce(dat$fu3m_completed & e3, FALSE))
  n6 <- sum(dplyr::coalesce(dat$fu6m_completed & e6, FALSE))
  ne <- sum(dplyr::coalesce((dat$fu3m_completed & e3) | (dat$fu6m_completed & e6), FALSE))

  tibble::tibble(
    `As of` = format(lock_date),
    Denominator = denom_label,

    `3m eligible (n)` = d3,
    `3m completed (n)` = n3,
    `3m completed (%)` = ifelse(d3 > 0, 100 * n3 / d3, NA_real_),

    `6m eligible (n)` = d6,
    `6m completed (n)` = n6,
    `6m completed (%)` = ifelse(d6 > 0, 100 * n6 / d6, NA_real_),

    `Either eligible (n)` = de,
    `Either completed (n)` = ne,
    `Either completed (%)` = ifelse(de > 0, 100 * ne / de, NA_real_)
  )
}

build_asof_rate_tables <- function(df, asof_dates) {
  out <- lapply(asof_dates, function(d) {
    dat <- prep_asof(df, d) %>% add_eligibility_flags(d)
    dplyr::bind_rows(
      summ_rates(dat, d, "ever_open"),
      summ_rates(dat, d, "closed")
    )
  })
  dplyr::bind_rows(out)
}

fu_rate_compare <- build_asof_rate_tables(df, ASOF_DATES)

# Split into two tables (one per denominator type) for readability
tbl_open <- fu_rate_compare %>% dplyr::filter(Denominator == "Window ever opened")
tbl_closed <- fu_rate_compare %>% dplyr::filter(Denominator == "Window closed")

gt::gt(tbl_open) %>%
  gt::fmt_number(columns = ends_with("(%)"), decimals = 1) %>%
  gt::tab_header(title = "Follow-up completion among those whose window EVER OPENED (by as-of date)") %>%
  gt::tab_source_note("Eligibility uses schedule min/max; completion requires status==1 and follow_visitdate <= lock date.")

gt::gt(tbl_closed) %>%
  gt::fmt_number(columns = ends_with("(%)"), decimals = 1) %>%
  gt::tab_header(title = "Follow-up completion among those whose window is CLOSED (by as-of date)") %>%
  gt::tab_source_note("Closed means follow_sch_max_*m <= lock date. Completion requires status==1 and follow_visitdate <= lock date.")
```

```{r diagnostic_denoms_only}
diagnose_denoms <- function(df, lock_date) {
  dat <- prep_asof(df, lock_date) %>% add_eligibility_flags(lock_date)

  tibble::tibble(
    `As of` = format(lock_date),
    N_baseline = n_distinct(dat$record_id),

    `3m ever-open (n)` = sum(coalesce(dat$elig_3m_ever_open, FALSE)),
    `3m closed (n)`    = sum(coalesce(dat$elig_3m_closed, FALSE)),

    `6m ever-open (n)` = sum(coalesce(dat$elig_6m_ever_open, FALSE)),
    `6m closed (n)`    = sum(coalesce(dat$elig_6m_closed, FALSE))
  )
}

den_diag <- dplyr::bind_rows(lapply(ASOF_DATES, function(d) diagnose_denoms(df, d)))

gt::gt(den_diag) %>%
  gt::tab_header(title = "Diagnostic: denominator sizes (ever-open vs closed) at each as-of date")
```

```{r baseline_date_detect}
# If you already have pick_by_regex from earlier, keep yours. Otherwise:
pick_by_regex <- function(df, regex_vec) {
  nms <- names(df)
  for (rx in regex_vec) {
    hit <- nms[stringr::str_detect(nms, stringr::regex(rx, ignore_case = TRUE))]
    if (length(hit)) return(hit[[1]])
  }
  NA_character_
}

# Reuse the same parser behavior
parse_date_any_safe <- function(x) {
  x <- as.character(x)
  dplyr::coalesce(
    suppressWarnings(as.Date(x)),
    suppressWarnings(as.Date(x, format = "%m/%d/%Y")),
    suppressWarnings(as.Date(x, format = "%m/%d/%y")),
    suppressWarnings(as.Date(x, format = "%Y/%m/%d")),
    suppressWarnings(as.Date(substr(x, 1, 10)))
  )
}

baseline_date_col <- pick_by_regex(df, c(
  "^baseline_date$",
  "baseline.*date",
  "^enroll_date$",
  "enroll.*date",
  "^icf_date$",
  "consent.*date",
  "^screen_date$",
  "screen.*date",
  "^visit_date$"
))

if (is.na(baseline_date_col)) {
  message("⚠️ Could not auto-detect a baseline date column. Falling back to merged_date.")
  baseline_date_col <- "merged_date"
}

message("Using baseline date column: ", baseline_date_col)
```

---

## Drop-in 2 — build Adam’s headline metric (Either completed among those with ≥1 window closed)

**This gives Aug 1, 2025 vs Jan 1, 2026 in one table**.
```{r either_closed_headline_table}
# Build as-of datasets for each lock date, add eligibility flags, add baseline_date_parsed,
# and compute "closed-either" denominator + "either completed" numerator.

prep_for_adam <- function(df, lock_date) {
  dat <- prep_asof(df, lock_date) %>%
    add_eligibility_flags(lock_date) %>%
    dplyr::mutate(
      baseline_date_parsed = to_date_smart(.data[[baseline_date_col]]),

      # Denominator: at least one FU window is closed (wave-specific max dates)
      elig_closed_either = dplyr::coalesce(elig_3m_closed, FALSE) | dplyr::coalesce(elig_6m_closed, FALSE),

      # Numerator: completed either by lock date (as-of strict completion from prep_asof)
      completed_either = dplyr::coalesce(fu3m_completed, FALSE) | dplyr::coalesce(fu6m_completed, FALSE),

      # Helpful decomposition (for storytelling/debug)
      completed_3m_only = dplyr::coalesce(fu3m_completed, FALSE) & !dplyr::coalesce(fu6m_completed, FALSE),
      completed_6m_only = !dplyr::coalesce(fu3m_completed, FALSE) & dplyr::coalesce(fu6m_completed, FALSE),
      completed_both    = dplyr::coalesce(fu3m_completed, FALSE) & dplyr::coalesce(fu6m_completed, FALSE)
    )
  dat
}

headline_rows <- lapply(ASOF_DATES, function(d) {
  dat <- prep_for_adam(df, d)

  denom <- sum(dat$elig_closed_either, na.rm = TRUE)
  num   <- sum(dat$elig_closed_either & dat$completed_either, na.rm = TRUE)

  tibble::tibble(
    `As of` = format(d),
    `Eligible (≥1 window closed) N` = denom,
    `Either completed (n)` = num,
    `Either completed (%)` = ifelse(denom > 0, 100 * num / denom, NA_real_),
    `3m only (n)` = sum(dat$elig_closed_either & dat$completed_3m_only, na.rm = TRUE),
    `6m only (n)` = sum(dat$elig_closed_either & dat$completed_6m_only, na.rm = TRUE),
    `Both (n)`    = sum(dat$elig_closed_either & dat$completed_both, na.rm = TRUE)
  )
})

headline_tbl <- dplyr::bind_rows(headline_rows)

gt::gt(headline_tbl) %>%
  gt::fmt_number(columns = ends_with("(%)"), decimals = 1) %>%
  gt::tab_header(title = "Either follow-up completed among participants with ≥1 follow-up window closed (as-of comparison)") %>%
  gt::tab_source_note("Denominator: follow_sch_max_3m <= lock OR follow_sch_max_6m <= lock (non-missing schedules). Numerator: follow_visitstatus==1 AND follow_visitdate <= lock (3m or 6m).")
```

---

## Drop-in 3 — “evidence we can reach 50%”: cohort trends (baseline month + year) using the Jan 1 lock

This is the single strongest evidence structure for DSMB: **later baseline cohorts show higher matured-cohort follow-up success**.
```{r cohort_trends_month_year}
LOCK_MAIN <- as.Date("2026-01-01")
dat_main <- prep_for_adam(df, LOCK_MAIN)

# keep only eligible matured sample for Adam’s headline metric
dat_mature <- dat_main %>%
  dplyr::filter(elig_closed_either) %>%
  dplyr::filter(!is.na(baseline_date_parsed))

# Cohort by baseline month
cohort_month <- dat_mature %>%
  dplyr::mutate(baseline_month = lubridate::floor_date(baseline_date_parsed, "month")) %>%
  dplyr::group_by(baseline_month) %>%
  dplyr::summarise(
    `Eligible N (≥1 window closed)` = dplyr::n(),
    `Either completed (n)` = sum(completed_either, na.rm = TRUE),
    `Either completed (%)` = 100 * mean(completed_either, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  dplyr::arrange(baseline_month)

gt::gt(cohort_month) %>%
  gt::fmt_number(columns = ends_with("(%)"), decimals = 1) %>%
  gt::tab_header(title = "Cohort trend (baseline month): Either completed among matured eligible (as of Jan 1, 2026)") %>%
  gt::tab_source_note("This is the matured-cohort metric: among those with ≥1 FU window closed by Jan 1, what % completed either 3m or 6m by Jan 1.")

# Cohort by baseline year (nice, simple DSMB framing)
cohort_year <- dat_mature %>%
  dplyr::mutate(baseline_year = lubridate::year(baseline_date_parsed)) %>%
  dplyr::group_by(baseline_year) %>%
  dplyr::summarise(
    `Eligible N (≥1 window closed)` = dplyr::n(),
    `Either completed (n)` = sum(completed_either, na.rm = TRUE),
    `Either completed (%)` = 100 * mean(completed_either, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  dplyr::arrange(baseline_year)

gt::gt(cohort_year) %>%
  gt::fmt_number(columns = ends_with("(%)"), decimals = 1) %>%
  gt::tab_header(title = "Cohort trend (baseline year): Either completed among matured eligible (as of Jan 1, 2026)")
```

---

## Drop-in 4 — “best evidence toward 50%”: show the *best recent cohorts* and what rate they hit

This gives you an evidence snippet like: “Recent cohorts have reached X% → plausibly improvable toward 50%.”
```{r evidence_recent_cohorts}
# Define "recent cohorts" window however you want. Here: last 6 baseline months present in the matured sample.
recent_months <- dat_mature %>%
  dplyr::mutate(baseline_month = lubridate::floor_date(baseline_date_parsed, "month")) %>%
  dplyr::distinct(baseline_month) %>%
  dplyr::arrange(dplyr::desc(baseline_month)) %>%
  dplyr::slice_head(n = 6) %>%
  dplyr::pull(baseline_month)

recent_summary <- dat_mature %>%
  dplyr::mutate(baseline_month = lubridate::floor_date(baseline_date_parsed, "month")) %>%
  dplyr::filter(baseline_month %in% recent_months) %>%
  dplyr::summarise(
    `Eligible N (recent months)` = dplyr::n(),
    `Either completed (n)` = sum(completed_either, na.rm = TRUE),
    `Either completed (%)` = 100 * mean(completed_either, na.rm = TRUE)
  )

best_months <- cohort_month %>%
  dplyr::filter(`Eligible N (≥1 window closed)` >= 20) %>%  # avoid tiny denominators
  dplyr::arrange(dplyr::desc(`Either completed (%)`)) %>%
  dplyr::slice_head(n = 6)

gt::gt(recent_summary) %>%
  gt::fmt_number(columns = ends_with("(%)"), decimals = 1) %>%
  gt::tab_header(title = "Recent-cohort performance (last 6 baseline months in matured eligible sample)")

gt::gt(best_months) %>%
  gt::fmt_number(columns = ends_with("(%)"), decimals = 1) %>%
  gt::tab_header(title = "Best baseline-month cohorts (≥20 eligible): Evidence of achievable follow-up performance")
```

---

## Drop-in 5 — “what would it take to reach 50%”: gap-to-target calculation (actionable DSMB framing)

This turns the story into: “We’re at X%. To reach 50%, we need Y additional follow-ups among those already matured-eligible.”
```{r gap_to_50}
LOCK_MAIN <- as.Date("2026-01-01")
dat_main <- prep_for_adam(df, LOCK_MAIN)

denom <- sum(dat_main$elig_closed_either, na.rm = TRUE)
num   <- sum(dat_main$elig_closed_either & dat_main$completed_either, na.rm = TRUE)

target_rate <- 0.50
target_n <- ceiling(target_rate * denom)
gap_n <- max(0, target_n - num)

gap_tbl <- tibble::tibble(
  `As of` = format(LOCK_MAIN),
  `Eligible (≥1 window closed) N` = denom,
  `Either completed (n)` = num,
  `Current rate (%)` = 100 * num / denom,
  `Target rate (%)` = 100 * target_rate,
  `Target completions needed (n)` = target_n,
  `Additional completions needed to reach target (n)` = gap_n
)

gt::gt(gap_tbl) %>%
  gt::fmt_number(columns = c(`Current rate (%)`, `Target rate (%)`), decimals = 1) %>%
  gt::tab_header(title = "Gap-to-50%: How many additional follow-ups are needed among matured-eligible participants?")
```






---

# 3) Table: “Either 3m or 6m completed” by baseline CSSR+ vs baseline CASSY- (two groups)

Interpretation: compare **baseline CSSR positive** vs **baseline CASSY negative** (two separate baseline-defined groups).

```{r table_either_by_cssrpos_vs_cassyneg}
either_tbl <- df_lock %>%
  mutate(
    group = case_when(
      cssr_pos_b == TRUE  ~ "Baseline CSSR+",
      cassy_pos_b == FALSE ~ "Baseline CASSY-",
      TRUE ~ NA_character_
    ),
    either_completed = fu3m_completed | fu6m_completed
  ) %>%
  filter(!is.na(group)) %>%
  group_by(group) %>%
  summarise(
    `Baseline group N` = n(),
    `Either 3m or 6m completed (n)` = sum(either_completed, na.rm = TRUE),
    `Either 3m or 6m completed (%)` = mean(either_completed, na.rm = TRUE) * 100,
    .groups = "drop"
  )

gt::gt(either_tbl) %>%
  gt::fmt_number(columns = ends_with("(%)"), decimals = 1) %>%
  gt::tab_header(title = "Either follow-up completion by baseline group (CSSR+ vs CASSY-), as of Jan 1, 2026")
```


---
# NEW TABLES

```{r}
# --- drop-in: attempt counts + completion flags as-of ---
ASOF_DATES <- as.Date(c("2025-08-01", "2026-01-01"))

# assumes you already have:
# - prep_asof(df, lock_date) that parses merged_date, follow_visitdate_3m/6m, follow_visitstatus_3m/6m
# - make_events_pid(df) that returns record_id, date, window

attempts_asof <- function(df_in, lock_date) {
  # events from *full* raw-ish df (must include outreach date fields)
  events <- make_events_pid(df_in) %>%
    mutate(date = as.Date(date)) %>%
    filter(!is.na(date), date < lock_date)

  # count attempts per participant-window
  att <- events %>%
    count(record_id, window, name = "outreach_attempts") %>%
    tidyr::pivot_wider(
      names_from = window,
      values_from = outreach_attempts,
      values_fill = 0
    ) %>%
    rename(att_3m = `3m`, att_6m = `6m`) %>%
    mutate(att_either = att_3m + att_6m)

  att
}

add_attempts_and_completions <- function(df_lock, df_in, lock_date) {
  att <- attempts_asof(df_in, lock_date)

  df_lock %>%
    mutate(record_id = as.character(record_id)) %>%
    left_join(att, by = "record_id") %>%
    mutate(
      att_3m = dplyr::coalesce(att_3m, 0L),
      att_6m = dplyr::coalesce(att_6m, 0L),
      att_either = dplyr::coalesce(att_either, 0L),

      completed_either = (fu3m_completed | fu6m_completed),

      any_outreach_3m = att_3m > 0,
      any_outreach_6m = att_6m > 0,
      any_outreach_either = att_either > 0
    )
}
```

```{r funnel table}

# --- drop-in: funnel as-of for matured-eligible ---
eligible_closed_flag <- function(dat, lock_date) {
  # expects follow_sch_max_3m / follow_sch_max_6m already parsed as Date (or parse here)

  dat %>%
    mutate(
      sch_max_3m = to_date_smart(follow_sch_max_3m),
      sch_max_6m = to_date_smart(follow_sch_max_6m),

      eligible_closed_3m = !is.na(sch_max_3m) & sch_max_3m < lock_date,
      eligible_closed_6m = !is.na(sch_max_6m) & sch_max_6m < lock_date,
      eligible_closed_either = eligible_closed_3m | eligible_closed_6m
    )
}

funnel_tbl_asof <- function(df_in, lock_date) {
  df_lock <- prep_asof(df_in, lock_date) %>%
    eligible_closed_flag(lock_date)

  df_lock2 <- add_attempts_and_completions(df_lock, df_in, lock_date) %>%
    filter(eligible_closed_either)

  tibble::tibble(
    as_of = format(lock_date),
    eligible_closed_N = n_distinct(df_lock2$record_id),
    any_outreach_n = sum(df_lock2$any_outreach_either, na.rm = TRUE),
    any_outreach_pct = 100 * mean(df_lock2$any_outreach_either, na.rm = TRUE),
    completed_n = sum(df_lock2$completed_either, na.rm = TRUE),
    completed_pct = 100 * mean(df_lock2$completed_either, na.rm = TRUE),
    completions_per_10_attempts = 10 * (sum(df_lock2$completed_either, na.rm = TRUE) / sum(df_lock2$att_either, na.rm = TRUE))
  )
}

funnel_all <- dplyr::bind_rows(lapply(ASOF_DATES, function(d) funnel_tbl_asof(raw, d)))

gt::gt(funnel_all) %>%
  gt::fmt_number(columns = c(any_outreach_pct, completed_pct, completions_per_10_attempts), decimals = 1) %>%
  gt::tab_header(title = "As-of funnel (matured eligible): outreach coverage + completion (Aug 1 vs Jan 1)")
```

```{r dose reponse}
dose_response_asof <- function(df_in, lock_date) {
  df_lock <- prep_asof(df_in, lock_date) %>%
    eligible_closed_flag(lock_date)

  df_lock2 <- add_attempts_and_completions(df_lock, df_in, lock_date) %>%
    filter(eligible_closed_either) %>%
    mutate(
      att_bin = case_when(
        att_either == 0 ~ "0",
        att_either %in% 1:2 ~ "1–2",
        att_either %in% 3:5 ~ "3–5",
        att_either >= 6 ~ "6+",
        TRUE ~ NA_character_
      )
    )

  df_lock2 %>%
    group_by(att_bin) %>%
    summarise(
      N = n_distinct(record_id),
      completed_n = sum(completed_either, na.rm = TRUE),
      completed_pct = 100 * mean(completed_either, na.rm = TRUE),
      .groups = "drop"
    ) %>%
    mutate(
      noncompleted_n   = N - completed_n,
      noncompleted_pct = 100 - completed_pct,
      as_of = format(lock_date)
    ) %>%
    select(as_of, att_bin, N, completed_n, noncompleted_n, completed_pct, noncompleted_pct)
}

dose_tbl <- bind_rows(
  dose_response_asof(raw, as.Date("2025-08-01")),
  dose_response_asof(raw, as.Date("2026-01-01"))
)

gt::gt(dose_tbl) %>%
  gt::fmt_number(columns = c(completed_pct, noncompleted_pct), decimals = 1) %>%
  gt::tab_header(title = "Completion vs non-completion by outreach attempt intensity (matured eligible)")
```

```{r outreach and completion table}
diag_outreach_missingness <- function(df_in, lock_date) {
  df_lock <- prep_asof(df_in, lock_date) %>%
    eligible_closed_flag(lock_date)

  df_lock2 <- add_attempts_and_completions(df_lock, df_in, lock_date) %>%
    filter(eligible_closed_either)

  df_lock2 %>%
    summarise(
      eligible_N = n_distinct(record_id),
      noncompleters_N = sum(!completed_either, na.rm = TRUE),
      noncompleters_with_any_outreach_pct = 100 * mean(any_outreach_either[!completed_either], na.rm = TRUE),
      completers_with_any_outreach_pct = 100 * mean(any_outreach_either[completed_either], na.rm = TRUE)
    )
}

print(diag_outreach_missingness(raw, as.Date("2026-01-01")))
```


```{r outreach + completed flags}
# =======================
# Outreach + completion prep (3m/6m)
# Requires: to_date_smart() already defined in your helpers
# =======================

get_outreach_cols <- function(dat, window) {
  stopifnot(window %in% c("3m","6m"))

  if (window == "3m") {
    # 3m has follow_outreach_1_3m plus outreachdate_2..15_3m
    cand <- c("follow_outreach_1_3m", paste0("follow_outreachdate_", 2:15, "_3m"))
  } else {
    # 6m has outreachdate_1..15_6m
    cand <- paste0("follow_outreachdate_", 1:15, "_6m")
  }

  intersect(cand, names(dat))
}

# --- Column lists from you ---
OUTREACH_COLS_3M <- c(
  "follow_outreach_1_3m",
  paste0("follow_outreachdate_", 2:15, "_3m")
)

OUTREACH_COLS_6M <- paste0("follow_outreachdate_", 1:15, "_6m")

# --- Build a long table of outreach attempts (dated) ---
outreach_long <- function(dat, window = c("3m","6m")) {
  window <- match.arg(window)

  cols <- if (window == "3m") OUTREACH_COLS_3M else OUTREACH_COLS_6M
  cols <- intersect(cols, names(dat))
  if (!length(cols)) {
    stop("No outreach columns found for window=", window,
         ". Check names(dat) and OUTREACH_COLS_*.")
  }

  dat %>%
    dplyr::transmute(record_id = as.character(record_id)) %>%
    dplyr::bind_cols(dat %>% dplyr::select(dplyr::all_of(cols))) %>%
    tidyr::pivot_longer(cols = dplyr::all_of(cols), names_to = "var", values_to = "raw") %>%
    dplyr::mutate(
      date = to_date_smart(raw),
      window = window
    ) %>%
    dplyr::filter(!is.na(date)) %>%
    dplyr::select(record_id, window, var, date)
}

# --- Turn outreach_long into attempt #1..#15 dates per participant, as-of lock_date ---
attempt_dates_wide <- function(dat, lock_date, window = c("3m","6m")) {
  window <- match.arg(window)

  ol <- outreach_long(dat, window) %>%
    dplyr::filter(date < lock_date) %>%
    dplyr::arrange(record_id, date) %>%
    dplyr::group_by(record_id) %>%
    dplyr::mutate(attempt_num = dplyr::row_number()) %>%
    dplyr::ungroup() %>%
    dplyr::filter(attempt_num <= 15)

  # attempt count as-of lock date
  attempt_count <- ol %>%
    dplyr::count(record_id, name = "attempts_asof")

  # wide attempt dates (may have only some attempt_date_k columns)
  wide <- ol %>%
    dplyr::mutate(attempt_col = paste0("attempt_date_", attempt_num)) %>%
    dplyr::select(record_id, attempt_col, date) %>%
    tidyr::pivot_wider(names_from = attempt_col, values_from = date)

  # ✅ FORCE all attempt_date_1..15 to exist
  for (k in 1:15) {
    nm <- paste0("attempt_date_", k)
    if (!nm %in% names(wide)) wide[[nm]] <- as.Date(NA)
  }

  # order columns nicely
  wide <- wide %>%
    dplyr::select(record_id, dplyr::all_of(paste0("attempt_date_", 1:15)))

  wide %>%
    dplyr::left_join(attempt_count, by = "record_id") %>%
    dplyr::mutate(attempts_asof = dplyr::coalesce(attempts_asof, 0L))
}

# --- Completion flag/date for a window (uses visitstatus==1, and visitdate<lock_date) ---
completion_asof <- function(dat, lock_date, window = c("3m","6m")) {
  window <- match.arg(window)

  if (window == "3m") {
    vd <- "follow_visitdate_3m"; vs <- "follow_visitstatus_3m"
  } else {
    vd <- "follow_visitdate_6m"; vs <- "follow_visitstatus_6m"
  }

  stopifnot(vd %in% names(dat), vs %in% names(dat))

  dat %>%
    dplyr::transmute(
      record_id = as.character(record_id),
      visit_date = to_date_smart(.data[[vd]]),
      visit_status = suppressWarnings(as.integer(as.character(.data[[vs]]))),
      completed_asof = (visit_status == 1L) & !is.na(visit_date) & (visit_date < lock_date)
      # If you truly want "status==1 regardless of date", use:
      # completed_asof = (visit_status == 1L)
    )
}

```

```{r}
build_outreach_long <- function(dat, lock_date, window) {
  cols <- get_outreach_cols(dat, window)
  if (!length(cols)) {
    return(tibble::tibble(record_id = character(), attempt_date = as.Date(character()), attempt = integer()))
  }

  dat %>%
    dplyr::transmute(record_id = as.character(record_id)) %>%
    dplyr::bind_cols(dat %>% dplyr::select(dplyr::all_of(cols))) %>%
    tidyr::pivot_longer(cols = dplyr::all_of(cols), names_to = "var", values_to = "raw") %>%
    dplyr::mutate(attempt_date = to_date_smart(raw)) %>%
    dplyr::filter(!is.na(attempt_date), attempt_date < lock_date) %>%
    dplyr::group_by(record_id) %>%
    dplyr::arrange(attempt_date, .by_group = TRUE) %>%
    dplyr::mutate(attempt = dplyr::row_number()) %>%
    dplyr::ungroup() %>%
    dplyr::select(record_id, attempt_date, attempt)
}
```



```{r}
# =======================
# Marginal completion yield by attempt number
# =======================

marginal_yield_by_attempt <- function(dat, lock_date, window,
                                      restrict_matured_eligible = TRUE) {
  stopifnot(window %in% c("3m","6m"))

  # prep_asof() should already:
  # - filter merged_date < lock
  # - filter treatment not NA
  # - parse fu visit dates
  df_lock <- prep_asof(dat, lock_date)

  # wave-specific "window closed" eligibility
  sch_max_col <- if (window == "3m") "follow_sch_max_3m" else "follow_sch_max_6m"
  df_lock <- df_lock %>%
    dplyr::mutate(
      sch_max = to_date_smart(.data[[sch_max_col]]),
      eligible_closed = !is.na(sch_max) & sch_max < lock_date
    )

  if (restrict_matured_eligible) df_lock <- df_lock %>% dplyr::filter(eligible_closed)

  # completion status (status==1 defines completed; still apply visit_date<lock)
  visit_date <- if (window == "3m") df_lock$fu3m_date_parsed else df_lock$fu6m_date_parsed
  status_ok  <- if (window == "3m") df_lock$fu3m_status       else df_lock$fu6m_status

  df_lock <- df_lock %>%
    dplyr::mutate(
      visit_date = visit_date,
      completed_asof = status_ok & !is.na(visit_date) & visit_date < lock_date
    )

  eligible_ids <- df_lock %>% dplyr::distinct(record_id)
  eligible_N   <- nrow(eligible_ids)

  # outreach attempts long (as-of)
  out_long <- build_outreach_long(dat, lock_date, window)
  # expects: record_id, attempt (int), attempt_date (Date)

  # attempts as-of per eligible person (0 if none)
  attempts_asof <- eligible_ids %>%
    dplyr::left_join(
      out_long %>%
        dplyr::group_by(record_id) %>%
        dplyr::summarise(attempts_asof = max(attempt, na.rm = TRUE), .groups="drop"),
      by = "record_id"
    ) %>%
    dplyr::mutate(attempts_asof = dplyr::coalesce(attempts_asof, 0L))

  # completers
  completers <- df_lock %>%
    dplyr::filter(completed_asof) %>%
    dplyr::select(record_id, visit_date)

  # attempt-at-completion = max attempt_date <= visit_date
  attempt_at_completion <- completers %>%
    dplyr::left_join(out_long, by = "record_id") %>%
    dplyr::filter(!is.na(attempt_date) & attempt_date <= visit_date) %>%
    dplyr::group_by(record_id) %>%
    dplyr::summarise(attempt_at_completion = max(attempt, na.rm = TRUE), .groups="drop")

  # default to 0 if no outreach attempt before the visit date
  completers2 <- completers %>%
    dplyr::left_join(attempt_at_completion, by = "record_id") %>%
    dplyr::mutate(attempt_at_completion = dplyr::coalesce(attempt_at_completion, 0L))

  # ----- marginal table (safe even if 0 eligible or 0 completers) -----
  if (eligible_N == 0L) {
    tab <- tibble::tibble(
      window = window,
      as_of = format(lock_date),
      completion_bucket = character(),
      eligible_N = integer(),
      completed_n = integer(),
      completed_pct_of_eligible = double()
    )
  } else {
    tab <- completers2 %>%
      dplyr::count(attempt_at_completion, name = "completed_n") %>%
      dplyr::mutate(
        eligible_N = eligible_N,
        completed_pct_of_eligible = 100 * completed_n / eligible_N,
        completion_bucket = dplyr::if_else(
          attempt_at_completion == 0L, "0 attempts", paste0("Attempt ", attempt_at_completion)
        ),
        window = window,
        as_of = format(lock_date)
      ) %>%
      dplyr::arrange(attempt_at_completion) %>%
      dplyr::select(window, as_of, completion_bucket, eligible_N, completed_n, completed_pct_of_eligible)
  }

  # ---- diagnostic: does marginal sum to total completions? ----
  total_completed <- sum(df_lock$completed_asof, na.rm = TRUE)
  summed <- sum(tab$completed_n, na.rm = TRUE)
  if (eligible_N > 0L && !identical(as.integer(total_completed), as.integer(summed))) {
    message("⚠️ Diagnostic: total completions=", total_completed,
            " but marginal buckets sum to ", summed,
            ". (Often means missing visit_date or outreach logged after visit.)")
  }

  list(
    summary = tab,
    detail_completers = completers2,
    detail_attempts_asof = attempts_asof
  )
}
```


```{r}
ASOF_DATES <- as.Date(c("2025-08-01", "2026-01-01"))

run_marginal_tables <- function(raw, window = c("3m","6m"), restrict_matured_eligible = TRUE) {
  window <- match.arg(window)

  res <- lapply(ASOF_DATES, function(d) {

    tmp <- marginal_yield_by_attempt(
      dat = raw,
      lock_date = d,
      window = window,
      restrict_matured_eligible = restrict_matured_eligible
    )

    # The table is returned in tmp$summary
    out <- tmp$summary
    if (is.null(out)) out <- tibble::tibble()

    # Ensure stable columns even if empty
    if (!("window" %in% names(out))) out$window <- window
    if (!("as_of" %in% names(out))) out$as_of <- format(d)
    if (!("completion_bucket" %in% names(out))) out$completion_bucket <- NA_character_
    if (!("eligible_N" %in% names(out))) out$eligible_N <- NA_integer_
    if (!("completed_n" %in% names(out))) out$completed_n <- NA_integer_
    if (!("completed_pct_of_eligible" %in% names(out))) out$completed_pct_of_eligible <- NA_real_

    out %>%
      dplyr::select(window, as_of, completion_bucket, eligible_N, completed_n, completed_pct_of_eligible)
  })

  dplyr::bind_rows(res)
}

marg_3m <- run_marginal_tables(raw, "3m", restrict_matured_eligible = TRUE)
marg_6m <- run_marginal_tables(raw, "6m", restrict_matured_eligible = TRUE)

gt::gt(marg_3m) %>% gt::tab_header(title = "3m: Marginal completion yield by outreach attempt (matured eligible)")
gt::gt(marg_6m) %>% gt::tab_header(title = "6m: Marginal completion yield by outreach attempt (matured eligible)")
```