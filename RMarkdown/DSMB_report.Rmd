---
title: "WeCare Section 3: Enrollment (CONSORT Diagram)"
author: "Auto-generated"
output:
  html_document:
    toc: true
    toc_depth: 2
    df_print: paged
---

```{r setup, message=FALSE, warning=FALSE}
# Packages
pkgs <- c(
  "tidyverse","lubridate","janitor","readr","glue","gt",
  "DiagrammeR"
)
for(p in pkgs) if(!requireNamespace(p, quietly = TRUE)) install.packages(p)
invisible(lapply(pkgs, library, character.only = TRUE))

# (Optional) nicer tables
theme_set(theme_minimal(base_size = 13))

# ---------- USER INPUTS ----------
OUT_DIR   <- OUT_DIR %||% "."   # if OUT_DIR not set
csv_path  <- file.path(OUT_DIR, "dat_merged.csv")
DATA_LOCK <- as.Date("2025-10-01")  # used in some filters; update as needed

# ---------- HELPERS ----------
na_empty <- function(x) replace(x, is.na(x) | x %in% c("NA",""), NA)

# Robust parser: handles Y-m-d, Y-m-d H:M[:S], m/d/Y variants, and Excel serials
parse_any_datetime <- function(x) {
  if (inherits(x, "POSIXct")) return(x)
  if (inherits(x, "Date"))    return(as.POSIXct(x))
  x <- na_empty(as.character(x))

  # Excel serials (1899-12-30 origin); only apply to reasonable ranges
  maybe_excel <- suppressWarnings(as.numeric(x))
  is_excel <- !is.na(maybe_excel) & maybe_excel > 20000 & maybe_excel < 90000
  res <- rep(NA_real_, length(x))

  # Parse ISO / common text dates first
  res_txt <- suppressWarnings(
    lubridate::parse_date_time(
      x,
      orders = c("Ymd HMS","Ymd HM","Ymd",
                 "Y-m-d H:M:S","Y-m-d H:M","Y-m-d",
                 "mdY HMS","mdY HM","mdY"),
      tz = "UTC",
      truncated = 3
    )
  )

  res[!is.na(res_txt)] <- as.numeric(res_txt[!is.na(res_txt)])

  # Fill remaining with Excel-serial interpretation
  if (any(is_excel, na.rm = TRUE)) {
    res_excel <- as.POSIXct(as.Date("1899-12-30") + maybe_excel[is_excel], tz = "UTC")
    res[is_excel] <- as.numeric(res_excel)
  }

  as.POSIXct(res, origin = "1970-01-01", tz = "UTC")
}

coalesce_chr <- function(...) {
  args <- list(...)
  args <- lapply(args, na_empty)
  out <- args[[1]]
  for(i in seq_along(args)[-1]) out <- dplyr::coalesce(out, args[[i]])
  out
}
n_distinct_na <- function(x) dplyr::n_distinct(na.omit(x))

# Attempt to load 'consort' if available for a pretty diagram;
# otherwise we will generate DOT with DiagrammeR.
has_consort <- requireNamespace("consort", quietly = TRUE)
```

#1) Load & Normalize 
```{r warning=FALSE, message=FALSE}
raw <- read_csv(csv_path, show_col_types = FALSE) |>
  mutate(across(everything(), \(x) if(is.character(x)) na_empty(x) else x)) |>
  clean_names()
dim(raw)

#--------------Destring "numbers with NA" & blank-ify literal "NA"-------------#
dat <- raw |>
  mutate(across(where(is.character), na_empty)) |>
  mutate(across(where(is.logical), as.integer)) |>
  mutate(across(where(is.character), \(x) type.convert(x, as.is = TRUE)))
```
# 2) Merge Dates & Initial Checks 
```{r warning=FALSE, message=FALSE}
# --- Merge dates & initial checks (robust) ---
# dat <- dat |>
#  mutate(
#    ps_date_dt          = parse_any_datetime(ps_date),
#    p_ps_date_dt        = parse_any_datetime(p_ps_date),
#    screen_doe_dt       = parse_any_datetime(screen_doe),
#    date_baseline_dt    = parse_any_datetime(date_baseline),
#    p_date_baseline_dt  = parse_any_datetime(p_date_baseline),

#    merged_datetime = coalesce(
#      ps_date_dt, p_ps_date_dt, screen_doe_dt, date_baseline_dt, p_date_baseline_dt
#    ),
#    merged_date = as.Date(merged_datetime)
#  )

# Quick spot check row(s) you showed
# dat |>
#  select(merged_date, ps_date, p_ps_date, screen_doe, date_baseline, p_date_baseline) |>
#  head(10) |>
#  gt::gt() |>
#  gt::tab_header(title = "Post-fix: merged_date now populated when any source has a timestamp")

# Check: any missing merged dates?
# miss_merged_date <- dat |>
#  filter(is.na(merged_date)) |>
#  select(record_id, ps_date, p_ps_date, screen_doe, date_baseline, p_date_baseline)

# gt::gt(miss_merged_date) |>
#  gt::tab_header(title = "Check: Remaining missing merged_date (should be few/none)")
```

# 3) Preeligibility Counts & Data Issues 
```{r warning=FALSE, message=FALSE}
youth_approached_n <- n_distinct_na(dat$record_id)

no_legal_guardian <- dat |>
  filter(over_18 == 0, p_screen_legal_guardian == 0) |>
  select(record_id)
no_legal_guardian_n <- nrow(no_legal_guardian)

no_english <- dat |>
  filter(p_screen_understand_eng == 0) |>
  select(record_id)
no_english_n <- nrow(no_english)

list(
  youth_approached_n = youth_approached_n,
  under_18_no_guardian_n = no_legal_guardian_n,
  no_english_n = no_english_n
)
```

# 4) Composite "hear_more" + trim to interested 
```{r warning=FALSE, message=FALSE}
dat <- dat |>
  mutate(
    merged_hear_more = coalesce(ps_hear_more, p_ps_hear_more)
  )

# Manual fixes
dat <- dat |>
  mutate(
    merged_hear_more = if_else(record_id %in% c("K-F0006","H-F0115","K-F0250"),
                               1L, merged_hear_more),
    merged_hear_more = replace_na(merged_hear_more, 0L)
  )

consented_to_hear_more_n    <- sum(dat$merged_hear_more == 1, na.rm = TRUE)
did_not_consent_hear_more_n <- sum(dat$merged_hear_more == 0, na.rm = TRUE)

# Check: anyone with treatment assigned but not interested in hearing more?
chk_treat_but_no_interest <- dat |>
  filter(!is.na(treatment), merged_hear_more == 0) |>
  select(record_id, treatment)
gt::gt(chk_treat_but_no_interest) |>
  gt::tab_header(title = "Check: Treatment present but 'hear more' == 0")

# Keep only those interested
dat <- dat |>
  filter(merged_hear_more == 1)
```

# 5) Eligibility Screen Completion 
```{r warning=FALSE, message=FALSE}
# 5) Eligibility Screen Completion  -------------------------------------------
# Compute counts BEFORE filtering
dat <- dat |>
  mutate(
    eligibility_screen_complete = replace_na(eligibility_screen_complete, 0L),
    eligibility_screen_complete = if_else(eligibility_screen_complete == 2, 2L, 0L)
  )

# These are the two stage counts you want:
did_not_wish_participate_n <- sum(dat$eligibility_screen_complete == 0, na.rm = TRUE)
completed_elg_screen_n     <- sum(dat$eligibility_screen_complete == 2, na.rm = TRUE)

# Save a copy of this stage to build `elg_stage` in Section 6
dat_s5 <- dat

# Now trim to completed screens for downstream work
dat <- dat |> filter(eligibility_screen_complete == 2)

did_not_wish_participate_n
completed_elg_screen_n
```

#6) Eligibility Criteria (Screen) 
```{r warning=FALSE, message=FALSE}
# 6) Eligibility Criteria (Screen) --------------------------------------------
# Build from the Section 5 snapshot (completed screens only)
elg_stage <- dat_s5 |> filter(eligibility_screen_complete == 2)

# --- Composite: Black (any race==1) ---
elg_stage <- elg_stage |>
  mutate(
    merge_black = if_else(
      rowSums(across(c(screen_race_1, screen_race_2, screen_race_3, screen_race_4), ~ .x == 1),
              na.rm = TRUE) >= 1, 1L, 0L)
  )

# --- Age rule (12–19), with manual override ---
elg_stage <- elg_stage |>
  mutate(
    elg_age = case_when(
      !is.na(screen_age) & screen_age >= 12 & screen_age < 20 ~ 1L,
      !is.na(screen_age) & (screen_age < 12 | screen_age >= 20) ~ 0L,
      TRUE ~ NA_integer_
    ),
    elg_age = if_else(record_id == "H-F0023", 1L, elg_age)
  )

# --- Helper: flip to 0 only when condition is TRUE; treat NA as FALSE ---
flip0 <- function(cur, cond) dplyr::if_else(dplyr::coalesce(cond, FALSE), 0L, cur)

# --- Build eligible_screen starting at 1, then apply exclusions ---
eligible_screen <- rep(1L, nrow(elg_stage))
eligible_screen <- flip0(eligible_screen, elg_stage$merge_black == 0)
eligible_screen <- flip0(eligible_screen, elg_stage$elg_age != 1)
eligible_screen <- flip0(eligible_screen, elg_stage$screen_speak_read_english == 0)
eligible_screen <- flip0(eligible_screen, elg_stage$screen_seek_therapy == 1)
eligible_screen <- flip0(eligible_screen, elg_stage$screen_self_repeat == 1)
eligible_screen <- flip0(eligible_screen, elg_stage$screen_sibling_repeat == 1)
eligible_screen <- flip0(eligible_screen, elg_stage$p_screen_sibling_repeat == 1)
eligible_screen <- flip0(
  eligible_screen,
  elg_stage$screen_has_cell_phone == 0 & elg_stage$merged_date < lubridate::ymd("2025-01-01")
)
eligible_screen <- ifelse(elg_stage$record_id == "H-F0269", 1L, eligible_screen)

elg_stage$eligible_screen <- eligible_screen

# ---- Stage counts you asked for (DO NOT overwrite did_not_wish_participate_n) ----
ineligible_prescreen_n        <- sum(elg_stage$eligible_screen == 0, na.rm = TRUE)
eligibility_screen_eligible_n <- sum(elg_stage$eligible_screen == 1, na.rm = TRUE)

print(table(elg_stage$eligible_screen, useNA = "ifany"))

# ---- Proceed to next stage with only screen-eligible ----
dat <- elg_stage |> filter(eligible_screen == 1)

# ---- Proceed to next stage with only screen-eligible ----
dat <- elg_stage |> filter(eligible_screen == 1)

# How many eligibles have missing key fields?
elg_stage |> 
  summarize(
    n = dplyr::n(),
    na_speak        = sum(is.na(screen_speak_read_english)),
    na_seektherapy  = sum(is.na(screen_seek_therapy)),
    na_selfrepeat   = sum(is.na(screen_self_repeat)),
    na_sibrepeat    = sum(is.na(screen_sibling_repeat) & is.na(p_screen_sibling_repeat)),
    na_cellphone    = sum(is.na(screen_has_cell_phone)),
    na_age          = sum(is.na(elg_age)),
    na_race_all     = sum((is.na(screen_race_1) & is.na(screen_race_2) &
                           is.na(screen_race_3) & is.na(screen_race_4)))
  )

# Why ineligible? (counts per rule)
elg_stage |>
  mutate(
    rule_black     = merge_black == 0,
    rule_age       = elg_age != 1 & !is.na(elg_age),
    rule_speak     = screen_speak_read_english == 0,
    rule_seekther  = screen_seek_therapy == 1,
    rule_selfrep   = screen_self_repeat == 1,
    rule_sibrepeat = screen_sibling_repeat == 1 | p_screen_sibling_repeat == 1,
    rule_cellphone = screen_has_cell_phone == 0 & merged_date < lubridate::ymd("2025-01-01")
  ) |>
  filter(eligible_screen == 0) |>
  summarize(
    n_ineligible = dplyr::n(),
    black        = sum(rule_black,     na.rm = TRUE),
    age          = sum(rule_age,       na.rm = TRUE),
    speak        = sum(rule_speak,     na.rm = TRUE),
    seektherapy  = sum(rule_seekther,  na.rm = TRUE),
    selfrepeat   = sum(rule_selfrep,   na.rm = TRUE),
    sibrepeat    = sum(rule_sibrepeat, na.rm = TRUE),
    cellphone    = sum(rule_cellphone, na.rm = TRUE)
  )

table(elg_stage$eligible_screen, useNA = "ifany")

```

# 7) Eligibility Survey Rules
```{r warning=FALSE, message=FALSE}
# 7) Eligibility Survey Rules — build from Section 6's elg_stage --------------
s7_base <- elg_stage |> dplyr::filter(eligible_screen == 1)
eligibility_screen_eligible_n <- nrow(s7_base)

# 7.1 dichotomies (same thresholds as STATA)
s7 <- s7_base |>
  mutate(
    eligible_anxiety = rowSums(across(c(eligible_anxiety_1, eligible_anxiety_2)), na.rm = FALSE),
    eligible_anxious = case_when(
      !is.na(eligible_anxiety) & eligible_anxiety >= 4 ~ 1L,
      !is.na(eligible_anxiety) & eligible_anxiety <  4 ~ 0L,
      TRUE ~ NA_integer_
    ),
    eligible_depress = rowSums(across(c(eligible_depress_1, eligible_depress_2)), na.rm = FALSE),
    eligible_depression = case_when(
      !is.na(eligible_depress) & eligible_depress >= 4 ~ 1L,
      !is.na(eligible_depress) & eligible_depress <  4 ~ 0L,
      TRUE ~ NA_integer_
    ),
    eligible_sch_close = case_when(
      eligible_sch_connect_1 < 3 ~ 1L,
      eligible_sch_connect_1 >=3 ~ 0L,
      TRUE ~ NA_integer_
    ),
    eligible_sch_part = case_when(
      eligible_sch_connect_2 < 3 ~ 1L,
      eligible_sch_connect_2 >=3 ~ 0L,
      TRUE ~ NA_integer_
    ),
    eligible_self_harm_y = case_when(
      eligible_self_harm >= 1 ~ 1L,
      eligible_self_harm == 0 ~ 0L,
      TRUE ~ NA_integer_
    ),
    eligible_sleep_problem_y = case_when(
      eligible_sleep_problem_1 > 1 ~ 1L,
      eligible_sleep_problem_1 <= 1 ~ 0L,
      TRUE ~ NA_integer_
    )
  )

# 7.2 count answered items (rownonmiss in STATA)
s7 <- s7 |>
  mutate(
    eligible_survey_count = rowSums(across(
      c(eligible_visited_ed,
        eligible_hospitalized,
        eligible_taken_med,
        eligible_received_therapy,
        eligible_sought_counseling,
        eligible_anxious,
        eligible_depression,
        eligible_sch_close,
        eligible_sch_part,
        eligible_self_harm_y,
        eligible_sleep_problem_y),
      ~ !is.na(.x)
    ))
  )

# --- metrics BEFORE drop (exactly as STATA) ---
completed_eligibility_survey_n <- sum(s7$eligible_survey_count > 8, na.rm = TRUE)
did_not_wish_presurvey_n       <- eligibility_screen_eligible_n - completed_eligibility_survey_n

# 7.3 drop non-completers (<=8 answered)
s7 <- s7 |> filter(eligible_survey_count > 8)

# 7.4 overall survey eligibility (anymatch values(1)) + overrides
s7 <- s7 |>
  mutate(
    eligible_survey = if_else(
      rowSums(across(
        c(eligible_visited_ed,
          eligible_hospitalized,
          eligible_taken_med,
          eligible_received_therapy,
          eligible_sought_counseling,
          eligible_anxious,
          eligible_depression,
          eligible_sch_close,
          eligible_sch_part,
          eligible_self_harm_y,
          eligible_sleep_problem_y),
        ~ replace_na(.x, 0)
      )) >= 1, 1L, 0L
    ),
    eligible_survey = if_else(merged_date > lubridate::ymd("2024-12-04"), 1L, eligible_survey),
    eligible_survey = if_else(record_id %in% c("K-F0082","K-F0080"), 1L, eligible_survey)
  )

eligibility_survey_ineligible_n <- sum(s7$eligible_survey == 0, na.rm = TRUE)
eligibility_survey_eligible_n   <- sum(s7$eligible_survey == 1, na.rm = TRUE)

# hand off to Section 8:
dat <- s7              # completed survey (eligible & ineligible)

# should equal eligibility_screen_eligible_n
completed_eligibility_survey_n + did_not_wish_presurvey_n  

# Count Checks 
completed_eligibility_survey_n
did_not_wish_presurvey_n  
eligibility_survey_ineligible_n 
eligibility_survey_eligible_n   

# --- cache the Section 7 counts so later chunks reuse EXACTLY these values ---
s7_counts <- list(
  eligibility_screen_eligible_n = eligibility_screen_eligible_n,
  completed_eligibility_survey_n = completed_eligibility_survey_n,
  did_not_wish_presurvey_n       = did_not_wish_presurvey_n,
  eligibility_survey_eligible_n  = eligibility_survey_eligible_n,
  eligibility_survey_ineligible_n= eligibility_survey_ineligible_n
)

```

# 8) Consent + Randomization 
```{r warning=FALSE, message=FALSE}
# 8) Consent + Randomization  -------------------------------------------------
# Base for consent: ONLY those who were Eligibility Survey: Eligible
s8_base <- s7 |> dplyr::filter(eligible_survey == 1)

s8 <- s8_base |>
  dplyr::mutate(
    consent = dplyr::case_when(
      p_informed_consent_form_parent_complete == 2 & screen_age_group == 0 ~ 1L,
      informed_consent_form_youth_complete    == 2 & screen_age_group == 1 ~ 1L,
      record_id %in% c("H-F0115","H-F0085", "K-F0419") ~ 1L,  # verbal / form issues
      TRUE ~ 0L
    )
  )

# ------- NEW: collapse to unique participants before counting ----------------
# If there ever are duplicates per ID, we keep a single record per youth.
# - consent: whether consent==1 on ANY row
# - treatment: first non-missing assignment (0/1) if present
s8u <- s8 |>
  dplyr::arrange(record_id, merged_date) |>
  dplyr::group_by(record_id) |>
  dplyr::summarise(
    consent   = as.integer(any(consent == 1, na.rm = TRUE)),
    treatment = dplyr::coalesce(dplyr::first(na.omit(treatment)), NA),
    .groups = "drop"
  )

# ------- COUNTS: person-level for consent, row-level for randomization -------

# Person-level (unique youth) — same as you had
consented_n                 <- sum(s8u$consent == 1, na.rm = TRUE)
did_not_complete_baseline_n <- sum(is.na(s8u$treatment) & s8u$consent == 1)

# Row-level (each randomized row counts, even if a youth appears multiple times)
randomized_n <- sum(!is.na(s8$treatment))
treatment_n  <- sum(s8$treatment == 1, na.rm = TRUE)
control_n    <- sum(s8$treatment == 0, na.rm = TRUE)

# (Optional) For visibility only: person-level randomized in case you still want to compare
randomized_n_persons <- sum(!is.na(s8u$treatment) & s8u$consent == 1)

# ---- Section 8: Audits only (does NOT change counts above) ------------------

# Participants randomized but consent != 1 (ROW-LEVEL view)
rand_without_consent <- s8 |>
  dplyr::filter(!is.na(treatment) & (is.na(consent) | consent != 1)) |>
  dplyr::select(record_id, treatment, consent)

# Duplicate participant rows (can explain row vs person mismatches)
dups <- s8 |>
  dplyr::count(record_id, name = "rows") |>
  dplyr::filter(rows > 1)

# Consented (person-level) but no treatment (person-level)
consented_no_treatment <- s8u |>
  dplyr::filter(consent == 1 & is.na(treatment)) |>
  dplyr::select(record_id)

# Algebra checks (display-only). Note: with row-level randomized, the identity will not hold if duplicates exist.
algebra <- tibble::tibble(
  consented_n_persons = consented_n,
  randomized_n_rows   = randomized_n,
  did_not_complete_baseline_persons = did_not_complete_baseline_n,
  identity_diff_persons_vs_rows = consented_n - (did_not_complete_baseline_n + randomized_n_rows),
  randomized_n_persons = randomized_n_persons
)

# Show audits (purely informational)
gt::gt(rand_without_consent) |>
  gt::tab_header(title = "Audit (row-level): Randomized but consent != 1")

gt::gt(dups) |>
  gt::tab_header(title = "Audit: Duplicate participant IDs (row-level)")

gt::gt(consented_no_treatment) |>
  gt::tab_header(title = "Audit (person-level): Consented but no treatment")

gt::gt(algebra) |>
  gt::tab_header(title = "Info: Person-level consent vs Row-level randomization")

# Tiny info table for the algebra check (purely informational)
tibble::tibble(
  consented_n = consented_n,
  randomized_n = randomized_n,
  did_not_complete_baseline_n = did_not_complete_baseline_n,
  consented_minus_rand_minus_dncb = consented_n - randomized_n - did_not_complete_baseline_n
) |>
  gt::gt() |>
  gt::tab_header(title = "Algebra check: Consented ?= Randomized + Did not complete baseline")

```

# 9) Follow-ups: 3-Month & 6-Month
```{r warning=FALSE, message=FALSE}
# ---------- 9) Follow-ups: 3-Month & 6-Month  --------------------------------
LOCK <- DATA_LOCK  # you set DATA_LOCK earlier; e.g., as.Date("2025-08-01")

# Parse visit status into integers (handles labels/strings too)
coerce_status_num <- function(x) {
  x_chr <- as.character(x)
  out   <- suppressWarnings(readr::parse_number(x_chr))
  out[is.na(out) & grepl("Completed",  x_chr, ignore.case = TRUE)] <- 1L
  out[is.na(out) & grepl("Missed",     x_chr, ignore.case = TRUE)] <- 7L
  out[is.na(out) & grepl("Withdraw|Exit", x_chr, ignore.case = TRUE)] <- 6L
  out[is.na(out) & grepl("Active|In[- ]?progress", x_chr, ignore.case = TRUE)] <- 2L
  as.integer(out)
}

# Base: randomized rows from Section 8
rand <- s8 |> dplyr::filter(!is.na(treatment)) |>
  dplyr::mutate(
    treatment = as.integer(readr::parse_number(as.character(treatment))),
    # visit status
    visit3 = coerce_status_num(follow_visitstatus_3m),
    visit6 = coerce_status_num(follow_visitstatus_6m),
    # schedule windows (force to Date)
    min3 = lubridate::ymd(as.character(follow_sch_min_3m)),
    max3 = lubridate::ymd(as.character(follow_sch_max_3m)),
    min6 = lubridate::ymd(as.character(follow_sch_min_6m)),
    max6 = lubridate::ymd(as.character(follow_sch_max_6m)),
    # exits
    exit_base = (y_exit_wd_b == 1L),
    exit3     = (visit3 == 6L)
  )

# ---------------- Pre-3m counts (your “Treatment Active/Exited”) --------------
treatment_total <- sum(rand$treatment == 1, na.rm = TRUE)
control_total   <- sum(rand$treatment == 0, na.rm = TRUE)

t_exited_pre3m  <- sum(rand$exit_base & rand$treatment == 1, na.rm = TRUE)
c_exited_pre3m  <- sum(rand$exit_base & rand$treatment == 0, na.rm = TRUE)

t_active_pre3m  <- treatment_total - t_exited_pre3m
c_active_pre3m  <- control_total   - c_exited_pre3m

# ---------------- 3-month classification (exclude baseline exits) -------------
rand3 <- rand |> dplyr::filter(!exit_base)

open3      <- !is.na(rand3$min3) & rand3$min3 <= LOCK
in_window3 <- open3 & !is.na(rand3$max3) & LOCK <= rand3$max3

completed3 <- rand3$visit3 == 1L
exited3    <- rand3$exit3
missed3    <- open3 & !in_window3 & !completed3 & !exited3 & !is.na(rand3$max3)
active3    <- in_window3 & !completed3 & !exited3

# N under the 3-month boxes = window opened by LOCK (excluding baseline exits)
m3_t_total <- sum(open3 & rand3$treatment == 1L, na.rm = TRUE)
m3_c_total <- sum(open3 & rand3$treatment == 0L, na.rm = TRUE)

n3_t <- list(
  completed = sum(completed3 & rand3$treatment == 1L, na.rm = TRUE),
  active    = sum(active3    & rand3$treatment == 1L, na.rm = TRUE),
  missed    = sum(missed3    & rand3$treatment == 1L, na.rm = TRUE),
  exited    = sum(exited3    & rand3$treatment == 1L, na.rm = TRUE)
)
n3_c <- list(
  completed = sum(completed3 & rand3$treatment == 0L, na.rm = TRUE),
  active    = sum(active3    & rand3$treatment == 0L, na.rm = TRUE),
  missed    = sum(missed3    & rand3$treatment == 0L, na.rm = TRUE),
  exited    = sum(exited3    & rand3$treatment == 0L, na.rm = TRUE)
)

# ---------------- 6-month classification -------------------------------------
# Base for 6-month N: drop 3-month exits; N = min6 <= LOCK (same rule)
rand6_base <- rand3 |> dplyr::filter(!exit3)

open6      <- !is.na(rand6_base$min6) & rand6_base$min6 <= LOCK
in_window6 <- open6 & !is.na(rand6_base$max6) & LOCK <= rand6_base$max6

completed6 <- rand6_base$visit6 == 1L
# Per spec: 6-month "Exited" shows 3-month withdrawals (carry-forward)
exited6_t  <- sum(rand$exit3 & rand$treatment == 1L, na.rm = TRUE)
exited6_c  <- sum(rand$exit3 & rand$treatment == 0L, na.rm = TRUE)

missed6 <- open6 & !in_window6 & !completed6 & !is.na(rand6_base$max6)
active6 <- in_window6 & !completed6

m6_t_total <- sum(open6 & rand6_base$treatment == 1L, na.rm = TRUE)
m6_c_total <- sum(open6 & rand6_base$treatment == 0L, na.rm = TRUE)

n6_t <- list(
  completed = sum(completed6 & rand6_base$treatment == 1L, na.rm = TRUE),
  active    = sum(active6    & rand6_base$treatment == 1L, na.rm = TRUE),
  missed    = sum(missed6    & rand6_base$treatment == 1L, na.rm = TRUE),
  exited    = exited6_t
)
n6_c <- list(
  completed = sum(completed6 & rand6_base$treatment == 0L, na.rm = TRUE),
  active    = sum(active6    & rand6_base$treatment == 0L, na.rm = TRUE),
  missed    = sum(missed6    & rand6_base$treatment == 0L, na.rm = TRUE),
  exited    = exited6_c
)

# ---------------- Quick sanity (should NOT be all zeros) ----------------------
table(rand$visit3, useNA="ifany"); table(rand$visit6, useNA="ifany")
summary(rand$min3); summary(rand$max3); summary(rand$min6); summary(rand$max6)
```

# 9.5) Stage Counts
```{r warning=FALSE, message=FALSE}
# 9.5) Stage Counts  -----------------------------------------------------------
LOCK <- as.Date("2025-10-20")   # data-lock date for window logic

# ---------------- A0–A4 (unchanged from your working code) -------------------
youth_approached_n <- n_distinct_na(raw$record_id)

a1 <- raw |>
  mutate(
    ps_hear_more   = type.convert(ps_hear_more, as.is = TRUE),
    p_ps_hear_more = type.convert(p_ps_hear_more, as.is = TRUE),
    merged_hear_more = dplyr::coalesce(ps_hear_more, p_ps_hear_more),
    merged_hear_more = dplyr::if_else(record_id %in% c("K-F0006","H-F0115","K-F0250"), 1L, merged_hear_more),
    merged_hear_more = tidyr::replace_na(merged_hear_more, 0L)
  )
consented_to_hear_more_n    <- sum(a1$merged_hear_more == 1, na.rm = TRUE)
did_not_consent_hear_more_n <- sum(a1$merged_hear_more == 0, na.rm = TRUE)

stopifnot(exists("dat_s5"))
a2 <- dat_s5
completed_elg_screen_n     <- sum(a2$eligibility_screen_complete == 2, na.rm = TRUE)
did_not_wish_participate_n <- sum(a2$eligibility_screen_complete == 0, na.rm = TRUE)

# A3 rules (same as yours)
elg_stage <- a2 |> dplyr::filter(eligibility_screen_complete == 2)
flip0 <- function(cur, cond) dplyr::if_else(dplyr::coalesce(cond, FALSE), 0L, cur)
elg_stage <- elg_stage |>
  mutate(
    merge_black = dplyr::if_else(
      rowSums(across(c(screen_race_1, screen_race_2, screen_race_3, screen_race_4), ~ .x == 1), na.rm = TRUE) >= 1, 1L, 0L),
    elg_age = dplyr::case_when(
      !is.na(screen_age) & screen_age >= 12 & screen_age < 20 ~ 1L,
      !is.na(screen_age) & (screen_age < 12 | screen_age >= 20) ~ 0L,
      TRUE ~ NA_integer_
    ),
    elg_age = dplyr::if_else(record_id == "H-F0023", 1L, elg_age)
  )
eligible_screen <- rep(1L, nrow(elg_stage))
eligible_screen <- flip0(eligible_screen, elg_stage$merge_black == 0)
eligible_screen <- flip0(eligible_screen, elg_stage$elg_age != 1)
eligible_screen <- flip0(eligible_screen, elg_stage$screen_speak_read_english == 0)
eligible_screen <- flip0(eligible_screen, elg_stage$screen_seek_therapy == 1)
eligible_screen <- flip0(eligible_screen, elg_stage$screen_self_repeat == 1)
eligible_screen <- flip0(eligible_screen, elg_stage$screen_sibling_repeat == 1)
eligible_screen <- flip0(eligible_screen, elg_stage$p_screen_sibling_repeat == 1)
eligible_screen <- flip0(eligible_screen, elg_stage$screen_has_cell_phone == 0 & elg_stage$merged_date < lubridate::ymd("2025-01-01"))
eligible_screen <- ifelse(elg_stage$record_id == "H-F0269", 1L, eligible_screen)
elg_stage$eligible_screen <- eligible_screen

eligibility_screen_eligible_n <- sum(elg_stage$eligible_screen == 1, na.rm = TRUE)
ineligible_prescreen_n        <- sum(elg_stage$eligible_screen == 0, na.rm = TRUE)

# A4: reuse Section 7 results if available
if (exists("s7") && exists("s7_counts")) {
  eligibility_screen_eligible_n  <- s7_counts$eligibility_screen_eligible_n
  completed_eligibility_survey_n <- s7_counts$completed_eligibility_survey_n
  did_not_wish_presurvey_n       <- s7_counts$did_not_wish_presurvey_n
  eligibility_survey_eligible_n  <- s7_counts$eligibility_survey_eligible_n
  eligibility_survey_ineligible_n<- s7_counts$eligibility_survey_ineligible_n
  a4 <- s7
} else {
  stop("Section 7 outputs not found; please run Section 7 before 9.5.")
}

# ---------------- A5/A6: Consent (person) + Randomization (row) --------------
if (exists("s8") && exists("s8u")) {
  a5 <- s8
  consented_n                 <- sum(s8u$consent == 1, na.rm = TRUE)
  did_not_consent_n           <- sum(s8u$consent == 0, na.rm = TRUE)
  did_not_complete_baseline_n <- sum(is.na(s8u$treatment) & s8u$consent == 1)
  randomized_n <- sum(!is.na(s8$treatment))
  treatment_n  <- sum(s8$treatment == 1, na.rm = TRUE)
  control_n    <- sum(s8$treatment == 0, na.rm = TRUE)
} else {
  s8_base <- a4 |> dplyr::filter(eligible_survey == 1)
  s8 <- s8_base |>
    dplyr::mutate(
      consent = dplyr::case_when(
        p_informed_consent_form_parent_complete == 2 & screen_age_group == 0 ~ 1L,
        informed_consent_form_youth_complete    == 2 & screen_age_group == 1 ~ 1L,
        record_id %in% c("H-F0115","H-F0085","K-F0419") ~ 1L,
        TRUE ~ 0L
      )
    )
  s8u <- s8 |>
    dplyr::arrange(record_id, merged_date) |>
    dplyr::group_by(record_id) |>
    dplyr::summarise(
      consent   = as.integer(any(consent == 1, na.rm = TRUE)),
      treatment = dplyr::coalesce(dplyr::first(na.omit(treatment)), NA),
      .groups = "drop"
    )
  consented_n                 <- sum(s8u$consent == 1, na.rm = TRUE)
  did_not_consent_n           <- sum(s8u$consent == 0, na.rm = TRUE)
  did_not_complete_baseline_n <- sum(is.na(s8u$treatment) & s8u$consent == 1)
  randomized_n <- sum(!is.na(s8$treatment))
  treatment_n  <- sum(s8$treatment == 1, na.rm = TRUE)
  control_n    <- sum(s8$treatment == 0, na.rm = TRUE)
}

# Row-level randomized set
rand <- if (exists("rand")) rand else s8 |> dplyr::filter(!is.na(treatment))

# -------------------------- FOLLOW-UPS (defensive) ---------------------------
# ---------- LOCK ----------
LOCK <- DATA_LOCK

rand3_base <- rand |>
  dplyr::mutate(
    status3 = dplyr::case_when(
      follow_visitstatus_3m == 1 ~ "Completed",
      follow_visitstatus_3m == 6 ~ "Withdrawal",
      follow_visitstatus_3m == 7 ~ "Missed",
      follow_visitstatus_3m %in% 2:5 ~ "Active",
      TRUE ~ NA_character_
    ),
    status6 = dplyr::case_when(
      follow_visitstatus_6m == 1 ~ "Completed",
      follow_visitstatus_6m == 6 ~ "Withdrawal",
      follow_visitstatus_6m == 7 ~ "Missed",
      follow_visitstatus_6m %in% 2:5 ~ "Active",
      TRUE ~ NA_character_
    ),
    min3 = as.Date(follow_sch_min_3m),
    max3 = as.Date(follow_sch_max_3m),
    min6 = as.Date(follow_sch_min_6m),
    max6 = as.Date(follow_sch_max_6m)
  )

treat3 <- rand3_base |> dplyr::filter(treatment == 1)
ctrl3  <- rand3_base |> dplyr::filter(treatment == 0)

# Drop 3m withdrawals for 6m universe
treat6 <- treat3 |> dplyr::filter(status3 != "Withdrawal")
ctrl6  <- ctrl3  |> dplyr::filter(status3 != "Withdrawal")

# Helper: “not completed or exited” with NAs treated as TRUE
not_comp_or_exit3 <- function(df) is.na(df$status3) | !(df$status3 %in% c("Completed","Withdrawal"))
not_comp_or_exit6 <- function(df) is.na(df$status6) | !(df$status6 %in% c("Completed","Withdrawal"))

count3_strict <- function(df){
  in_scope <- !is.na(df$min3) & df$min3 <= LOCK

  completed <- sum(in_scope & df$status3 == "Completed",  na.rm = TRUE)
  exited    <- sum(in_scope & df$status3 == "Withdrawal", na.rm = TRUE)
  active    <- sum(in_scope & (LOCK <= df$max3) & not_comp_or_exit3(df), na.rm = TRUE)
  missed    <- sum(in_scope & (LOCK >  df$max3) & not_comp_or_exit3(df), na.rm = TRUE)

  total <- sum(in_scope, na.rm = TRUE)    # your definition
  stopifnot(total == completed + active + missed + exited)
  list(total=total, completed=completed, active=active, missed=missed, exited=exited)
}

count6_strict <- function(df){
  in_scope <- !is.na(df$min6) & df$min6 <= LOCK

  completed <- sum(in_scope & df$status6 == "Completed",  na.rm = TRUE)
  exited    <- 0L  # 3m withdrawals were removed already
  active    <- sum(in_scope & (LOCK <= df$max6) & not_comp_or_exit6(df), na.rm = TRUE)
  missed    <- sum(in_scope & (LOCK >  df$max6) & not_comp_or_exit6(df), na.rm = TRUE)

  total <- sum(in_scope, na.rm = TRUE)    # your definition
  stopifnot(total == completed + active + missed + exited)
  list(total=total, completed=completed, active=active, missed=missed, exited=exited)
}

n3_t <- count3_strict(treat3)
n3_c <- count3_strict(ctrl3)
n6_t <- count6_strict(treat6)
n6_c <- count6_strict(ctrl6)

n3_t_total <- n3_t$total; n3_c_total <- n3_c$total
n6_t_total <- n6_t$total; n6_c_total <- n6_c$total

treatment_active_pre3m  <- t_active_pre3m
control_active_pre3m    <- c_active_pre3m
treatment_exit_baseline <- t_exited_pre3m
control_exit_baseline   <- c_exited_pre3m

# ------------------------------- Build K -------------------------------------
K <- list(
  youth_approached = youth_approached_n,
  hear_more_yes    = consented_to_hear_more_n,
  hear_more_no     = did_not_consent_hear_more_n,

  did_not_wish_participate = did_not_wish_participate_n,
  completed_elg_screen     = completed_elg_screen_n,

  ineligible_prescreen     = ineligible_prescreen_n,
  elig_screen_eligible     = eligibility_screen_eligible_n,

  did_not_wish_presurvey   = did_not_wish_presurvey_n,
  completed_elig_survey    = completed_eligibility_survey_n,
  ineligible_presurvey     = eligibility_survey_ineligible_n,
  elig_survey_eligible     = eligibility_survey_eligible_n,

  did_not_consent           = did_not_consent_n,
  consented                 = consented_n,
  did_not_complete_baseline = did_not_complete_baseline_n,

  randomized = randomized_n,
  treatment  = treatment_n,
  control    = control_n,

  # Baseline status under arms
  t_active_pre3m = treatment_active_pre3m, t_exited_pre3m = treatment_exit_baseline,
  c_active_pre3m = control_active_pre3m,   c_exited_pre3m = control_exit_baseline,

  # 3-month
  m3_t_total = n3_t_total, m3_c_total = n3_c_total,
  m3_t_active = n3_t$active, m3_t_completed = n3_t$completed,
  m3_t_missed = n3_t$missed, m3_t_exited = n3_t$exited,
  m3_c_active = n3_c$active, m3_c_completed = n3_c$completed,
  m3_c_missed = n3_c$missed, m3_c_exited = n3_c$exited,

  # 6-month
  m6_t_total = n6_t_total, m6_c_total = n6_c_total,
  m6_t_active = n6_t$active, m6_t_completed = n6_t$completed,
  m6_t_missed = n6_t$missed, m6_t_exited = n6_t$exited, # will be 0
  m6_c_active = n6_c$active, m6_c_completed = n6_c$completed,
  m6_c_missed = n6_c$missed, m6_c_exited = n6_c$exited  # will be 0
)
```

```{r}
table_in_scope3 <- with(treat3, table(in_scope = (!is.na(min3) & min3 <= LOCK),
                                      status3 = addNA(status3)))
print(table_in_scope3)
```


# 10) CONSORT Diagram 
```{r warning=FALSE, message=FALSE}
# 10) CONSORT Diagram — split 3m/6m into separate boxes; only A/C/M go to 6m
{
  nz <- function(x) ifelse(is.na(x), 0L, x)

  lbl <- list(
    top              = glue::glue("Youth approached in ER\nN = {nz(K$youth_approached)}"),
    hear_more_y      = glue::glue("Consented to hear more\nn = {nz(K$hear_more_yes)}"),
    hear_more_n      = glue::glue("Did not consent to hear more\nn = {nz(K$hear_more_no)}"),

    elg_screen_cmpl  = glue::glue("Completed Eligibility Screen\nn = {nz(K$completed_elg_screen)}"),
    elg_screen_dnwp  = glue::glue("Did not wish to participate\nn = {nz(K$did_not_wish_participate)}"),

    elg_ineligible   = glue::glue("Ineligible\nn = {nz(K$ineligible_prescreen)}"),
    elg_screen_elig  = glue::glue("Eligibility Screen: Eligible\nn = {nz(K$elig_screen_eligible)}"),

    elg_svy_total    = glue::glue("Completed Eligibility Survey\nn = {nz(K$completed_elig_survey)}"),
    elg_svy_dnwp     = glue::glue("Did not wish to participate\nn = {nz(K$did_not_wish_presurvey)}"),
    elg_svy_inelig   = glue::glue("Ineligible\nn = {nz(K$ineligible_presurvey)}"),
    elg_svy_elig     = glue::glue("Eligibility Survey: Eligible\nn = {nz(K$elig_survey_eligible)}"),

    consented        = glue::glue("Consented\nn = {nz(K$consented)}"),
    did_not_consent  = glue::glue("Did not consent\nn = {nz(K$did_not_consent)}"),

    randomized       = glue::glue("Randomization\nn = {nz(K$randomized)}"),
    did_not_baseline = glue::glue("Did not complete baseline\nn = {nz(K$did_not_complete_baseline)}"),

    arm_t            = glue::glue("Treatment\nn = {nz(K$treatment)}"),
    arm_c            = glue::glue("Control\nn = {nz(K$control)}"),

    pre_t_act        = glue::glue("Active\nn = {nz(K$t_active_pre3m)}"),
    pre_t_exit       = glue::glue("Exited\nn = {nz(K$t_exited_pre3m)}"),
    pre_c_act        = glue::glue("Active\nn = {nz(K$c_active_pre3m)}"),
    pre_c_exit       = glue::glue("Exited\nn = {nz(K$c_exited_pre3m)}"),

    m3_t             = glue::glue("3-Month Follow Up: Treatment\nn = {nz(K$m3_t_total)}"),
    m3_c             = glue::glue("3-Month Follow Up: Control\nn = {nz(K$m3_c_total)}"),

    m3_t_act         = glue::glue("Active\nn = {nz(K$m3_t_active)}"),
    m3_t_comp        = glue::glue("Completed\nn = {nz(K$m3_t_completed)}"),
    m3_t_miss        = glue::glue("Missed\nn = {nz(K$m3_t_missed)}"),
    m3_t_exit        = glue::glue("Exited\nn = {nz(K$m3_t_exited)}"),

    m3_c_act         = glue::glue("Active\nn = {nz(K$m3_c_active)}"),
    m3_c_comp        = glue::glue("Completed\nn = {nz(K$m3_c_completed)}"),
    m3_c_miss        = glue::glue("Missed\nn = {nz(K$m3_c_missed)}"),
    m3_c_exit        = glue::glue("Exited\nn = {nz(K$m3_c_exited)}"),

    m6_t             = glue::glue("6-Month Follow Up: Treatment\nn = {nz(K$m6_t_total)}"),
    m6_c             = glue::glue("6-Month Follow Up: Control\nn = {nz(K$m6_c_total)}"),

    m6_t_act         = glue::glue("Active\nn = {nz(K$m6_t_active)}"),
    m6_t_comp        = glue::glue("Completed\nn = {nz(K$m6_t_completed)}"),
    m6_t_miss        = glue::glue("Missed\nn = {nz(K$m6_t_missed)}"),
    m6_t_exit        = glue::glue("Exited\nn = {nz(K$m6_t_exited)}"),

    m6_c_act         = glue::glue("Active\nn = {nz(K$m6_c_active)}"),
    m6_c_comp        = glue::glue("Completed\nn = {nz(K$m6_c_completed)}"),
    m6_c_miss        = glue::glue("Missed\nn = {nz(K$m6_c_missed)}"),
    m6_c_exit        = glue::glue("Exited\nn = {nz(K$m6_c_exited)}")
  )

  dot <- glue::glue('
  digraph consort {{
    graph [rankdir=TB, splines=ortho, nodesep="0.36", ranksep="0.46", bgcolor="white"];
    node  [shape=box, style="rounded,filled", fillcolor="white", color="black",
           fontname="Helvetica", fontsize=12, margin="0.10,0.07"];
    edge  [arrowhead=normal, color="black"];

    # main column
    top   [label="{lbl$top}"];
    hm_y  [label="{lbl$hear_more_y}"];
    elg_c [label="{lbl$elg_screen_cmpl}"];
    elg_e [label="{lbl$elg_screen_elig}"];
    svy_t [label="{lbl$elg_svy_total}"];
    svy_e [label="{lbl$elg_svy_elig}"];
    cons  [label="{lbl$consented}"];
    rand  [label="{lbl$randomized}"];

    # right column (shifted up)
    hm_n     [label="{lbl$hear_more_n}"];
    dnwp_pre [label="{lbl$elg_screen_dnwp}"];
    inel_scr [label="{lbl$elg_ineligible}"];
    dnwp_svy [label="{lbl$elg_svy_dnwp}"];
    inel_svy [label="{lbl$elg_svy_inelig}"];
    ncons    [label="{lbl$did_not_consent}"];
    nbase    [label="{lbl$did_not_baseline}"];

    g0 [label="", width=0.6, height=0.01, shape=box, style=invis];
    g1 [label="", width=0.6, height=0.01, shape=box, style=invis];
    g2 [label="", width=0.6, height=0.01, shape=box, style=invis];
    g3 [label="", width=0.6, height=0.01, shape=box, style=invis];
    g4 [label="", width=0.6, height=0.01, shape=box, style=invis];
    g5 [label="", width=0.6, height=0.01, shape=box, style=invis];
    g6 [label="", width=0.6, height=0.01, shape=box, style=invis];

    # arms
    arm_t [label="{lbl$arm_t}", width=2.6];
    arm_c [label="{lbl$arm_c}", width=2.6];

    # pre-3m status under arms
    t_act  [label="{lbl$pre_t_act}"];
    t_exit [label="{lbl$pre_t_exit}"];
    c_act  [label="{lbl$pre_c_act}"];
    c_exit [label="{lbl$pre_c_exit}"];

    # 3m totals
    m3_t [label="{lbl$m3_t}"];
    m3_c [label="{lbl$m3_c}"];

    # 3m breakdown (separate boxes)
    m3_t_act  [label="{lbl$m3_t_act}"];
    m3_t_comp [label="{lbl$m3_t_comp}"];
    m3_t_miss [label="{lbl$m3_t_miss}"];
    m3_t_exit [label="{lbl$m3_t_exit}"];

    m3_c_act  [label="{lbl$m3_c_act}"];
    m3_c_comp [label="{lbl$m3_c_comp}"];
    m3_c_miss [label="{lbl$m3_c_miss}"];
    m3_c_exit [label="{lbl$m3_c_exit}"];

    # 6m totals
    m6_t [label="{lbl$m6_t}"];
    m6_c [label="{lbl$m6_c}"];

    # 6m breakdown (separate boxes)
    m6_t_act  [label="{lbl$m6_t_act}"];
    m6_t_comp [label="{lbl$m6_t_comp}"];
    m6_t_miss [label="{lbl$m6_t_miss}"];
    m6_t_exit [label="{lbl$m6_t_exit}"];

    m6_c_act  [label="{lbl$m6_c_act}"];
    m6_c_comp [label="{lbl$m6_c_comp}"];
    m6_c_miss [label="{lbl$m6_c_miss}"];
    m6_c_exit [label="{lbl$m6_c_exit}"];

    # main flow
    top -> hm_y -> elg_c -> elg_e -> svy_t -> svy_e -> cons -> rand;

    # right column alignment + gutter
    {{ rank=same; top;   g0; hm_n;     }}
    {{ rank=same; hm_y;  g1; dnwp_pre; }}
    {{ rank=same; elg_c; g2; inel_scr; }}
    {{ rank=same; elg_e; g3; dnwp_svy; }}
    {{ rank=same; svy_t; g4; inel_svy; }}
    {{ rank=same; svy_e; g5; ncons;    }}
    {{ rank=same; cons;  g6; nbase;    }}

    # connectors to right column
    top  -> hm_n      [constraint=false];
    hm_y -> dnwp_pre  [constraint=false];
    elg_c -> inel_scr [constraint=false];
    elg_e -> dnwp_svy [constraint=false];
    svy_t -> inel_svy [constraint=false];
    svy_e -> ncons    [constraint=false];
    cons  -> nbase    [constraint=false];

    # ARMS + pre-3m
    rand -> arm_t; rand -> arm_c;
    {{ rank=same; arm_t; arm_c; }}

    arm_t -> t_act; arm_t -> t_exit;
    arm_c -> c_act; arm_c -> c_exit;
    {{ rank=same; t_act; t_exit; }}
    {{ rank=same; c_act; c_exit; }}

    # 3m totals under actives
    t_act -> m3_t;
    c_act -> m3_c;
    {{ rank=same; m3_t; m3_c; }}

    # 3m breakdown directly under 3m totals
    m3_t -> m3_t_act;  m3_t -> m3_t_comp;  m3_t -> m3_t_miss;  m3_t -> m3_t_exit;
    m3_c -> m3_c_act;  m3_c -> m3_c_comp;  m3_c -> m3_c_miss;  m3_c -> m3_c_exit;
    {{ rank=same; m3_t_act; m3_t_comp; m3_t_miss; m3_t_exit; }}
    {{ rank=same; m3_c_act; m3_c_comp; m3_c_miss; m3_c_exit; }}

    # ONLY Active/Completed/Missed flow to 6m totals (Exited does NOT)
    m3_t_act  -> m6_t;
    m3_t_comp -> m6_t;
    m3_t_miss -> m6_t;

    m3_c_act  -> m6_c;
    m3_c_comp -> m6_c;
    m3_c_miss -> m6_c;

    {{ rank=same; m6_t; m6_c; }}

    # 6m breakdown under 6m totals
    m6_t -> m6_t_act;  m6_t -> m6_t_comp;  m6_t -> m6_t_miss;  m6_t -> m6_t_exit;
    m6_c -> m6_c_act;  m6_c -> m6_c_comp;  m6_c -> m6_c_miss;  m6_c -> m6_c_exit;
    {{ rank=same; m6_t_act; m6_t_comp; m6_t_miss; m6_t_exit; }}
    {{ rank=same; m6_c_act; m6_c_comp; m6_c_miss; m6_c_exit; }}
  }}
  ')
  DiagrammeR::grViz(dot)
}
```


# 11) QC Summary Quick Table 
```{r warning=FALSE, message=FALSE}
# 11) QC Summary Quick Table — every requested metric comes from K -------------
nz <- function(x) ifelse(is.na(x), 0L, x)

qc_tbl <- tibble::tibble(
  Metric = c(
    "Youth approached in ER",
    "Did not consent to hear more",
    "Consented to hear more",

    "Did not wish to participate (pre-screen)",
    "Completed Eligibility Screen",
    "Ineligible (pre Eligibility Screen: Eligible)",
    "Eligibility Screen: Eligible",

    "Did not wish to participate (pre-survey)",
    "Completed Eligibility Survey",
    "Ineligible (pre Eligibility Survey: Eligible)",
    "Eligibility Survey: Eligible",

    "Did not consent",
    "Consented",
    "Did not complete baseline",

    "Randomization",
    "Treatment",
    "Treatment Active",
    "Treatment Exited",

    "3-Month Follow Up: Treatment",
    "3-Month Follow Up: Treatment Active",
    "3-Month Follow Up: Treatment Completed",
    "3-Month Follow Up: Treatment Missed",
    "3-Month Follow Up: Treatment Exited",

    "6-Month Follow Up: Treatment",
    "6-Month Follow Up: Treatment Active",
    "6-Month Follow Up: Treatment Completed",
    "6-Month Follow Up: Treatment Missed",
    "6-Month Follow Up: Treatment Exited",

    "Control",
    "Control Active",
    "Control Exited",

    "3-Month Follow Up: Control",
    "3-Month Follow Up: Control Active",
    "3-Month Follow Up: Control Completed",
    "3-Month Follow Up: Control Missed",
    "3-Month Follow Up: Control Exited",

    "6-Month Follow Up: Control",
    "6-Month Follow Up: Control Active",
    "6-Month Follow Up: Control Completed",
    "6-Month Follow Up: Control Missed",
    "6-Month Follow Up: Control Exited"
  ),
  n = c(
    nz(K$youth_approached),
    nz(K$hear_more_no),
    nz(K$hear_more_yes),

    nz(K$did_not_wish_participate),
    nz(K$completed_elg_screen),
    nz(K$ineligible_prescreen),
    nz(K$elig_screen_eligible),

    nz(K$did_not_wish_presurvey),
    nz(K$completed_elig_survey),
    nz(K$ineligible_presurvey),
    nz(K$elig_survey_eligible),

    nz(K$did_not_consent),
    nz(K$consented),
    nz(K$did_not_complete_baseline),

    nz(K$randomized),
    nz(K$treatment),
    nz(K$t_active_pre3m),
    nz(K$t_exited_pre3m),

    nz(K$m3_t_total),
    nz(K$m3_t_active),
    nz(K$m3_t_completed),
    nz(K$m3_t_missed),
    nz(K$m3_t_exited),

    nz(K$m6_t_total),
    nz(K$m6_t_active),
    nz(K$m6_t_completed),
    nz(K$m6_t_missed),
    nz(K$m6_t_exited),

    nz(K$control),
    nz(K$c_active_pre3m),
    nz(K$c_exited_pre3m),

    nz(K$m3_c_total),
    nz(K$m3_c_active),
    nz(K$m3_c_completed),
    nz(K$m3_c_missed),
    nz(K$m3_c_exited),

    nz(K$m6_c_total),
    nz(K$m6_c_active),
    nz(K$m6_c_completed),
    nz(K$m6_c_missed),
    nz(K$m6_c_exited)
  )
)

qc_tbl |>
  gt::gt() |>
  gt::tab_header(title = "CONSORT: Count Summary (Source of Truth)") |>
  gt::fmt_number(columns = "n", decimals = 0)
```
