---
title: "WeCare — Section 3: Enrollment (CONSORT Diagram)"
author: "Auto-generated"
output:
  html_document:
    toc: true
    toc_depth: 2
    df_print: paged
---

```{r setup, message=FALSE, warning=FALSE}
# Packages
pkgs <- c(
  "tidyverse","lubridate","janitor","readr","glue","gt",
  "DiagrammeR"
)
for(p in pkgs) if(!requireNamespace(p, quietly = TRUE)) install.packages(p)
invisible(lapply(pkgs, library, character.only = TRUE))

# (Optional) nicer tables
theme_set(theme_minimal(base_size = 13))

# ---------- USER INPUTS ----------
OUT_DIR   <- OUT_DIR %||% "."   # if OUT_DIR not set
csv_path  <- file.path(OUT_DIR, "dat_merged.csv")
DATA_LOCK <- as.Date("2025-08-01")  # used in some filters; update as needed

# ---------- HELPERS ----------
na_empty <- function(x) replace(x, is.na(x) | x %in% c("NA",""), NA)

# Robust parser: handles Y-m-d, Y-m-d H:M[:S], m/d/Y variants, and Excel serials
parse_any_datetime <- function(x) {
  if (inherits(x, "POSIXct")) return(x)
  if (inherits(x, "Date"))    return(as.POSIXct(x))
  x <- na_empty(as.character(x))

  # Excel serials (1899-12-30 origin); only apply to reasonable ranges
  maybe_excel <- suppressWarnings(as.numeric(x))
  is_excel <- !is.na(maybe_excel) & maybe_excel > 20000 & maybe_excel < 90000
  res <- rep(NA_real_, length(x))

  # Parse ISO / common text dates first
  res_txt <- suppressWarnings(
    lubridate::parse_date_time(
      x,
      orders = c("Ymd HMS","Ymd HM","Ymd",
                 "Y-m-d H:M:S","Y-m-d H:M","Y-m-d",
                 "mdY HMS","mdY HM","mdY"),
      tz = "UTC",
      truncated = 3
    )
  )

  res[!is.na(res_txt)] <- as.numeric(res_txt[!is.na(res_txt)])

  # Fill remaining with Excel-serial interpretation
  if (any(is_excel, na.rm = TRUE)) {
    res_excel <- as.POSIXct(as.Date("1899-12-30") + maybe_excel[is_excel], tz = "UTC")
    res[is_excel] <- as.numeric(res_excel)
  }

  as.POSIXct(res, origin = "1970-01-01", tz = "UTC")
}

coalesce_chr <- function(...) {
  args <- list(...)
  args <- lapply(args, na_empty)
  out <- args[[1]]
  for(i in seq_along(args)[-1]) out <- dplyr::coalesce(out, args[[i]])
  out
}
n_distinct_na <- function(x) dplyr::n_distinct(na.omit(x))

# Attempt to load 'consort' if available for a pretty diagram;
# otherwise we will generate DOT with DiagrammeR.
has_consort <- requireNamespace("consort", quietly = TRUE)
```

#1) Load & Normalize 
```{r warning=FALSE, message=FALSE}
raw <- read_csv(csv_path, show_col_types = FALSE) |>
  mutate(across(everything(), \(x) if(is.character(x)) na_empty(x) else x)) |>
  clean_names()
dim(raw)

#--------------Destring "numbers with NA" & blank-ify literal "NA"-------------#
dat <- raw |>
  mutate(across(where(is.character), na_empty)) |>
  mutate(across(where(is.logical), as.integer)) |>
  mutate(across(where(is.character), \(x) type.convert(x, as.is = TRUE)))
```
# 2) Merge Dates & Initial Checks 
```{r warning=FALSE, message=FALSE}
# --- Merge dates & initial checks (robust) ---
dat <- dat |>
  mutate(
    ps_date_dt          = parse_any_datetime(ps_date),
    p_ps_date_dt        = parse_any_datetime(p_ps_date),
    screen_doe_dt       = parse_any_datetime(screen_doe),
    date_baseline_dt    = parse_any_datetime(date_baseline),
    p_date_baseline_dt  = parse_any_datetime(p_date_baseline),

    merged_datetime = coalesce(
      ps_date_dt, p_ps_date_dt, screen_doe_dt, date_baseline_dt, p_date_baseline_dt
    ),
    merged_date = as.Date(merged_datetime)
  )

# Quick spot check row(s) you showed
dat |>
  select(merged_date, ps_date, p_ps_date, screen_doe, date_baseline, p_date_baseline) |>
  head(10) |>
  gt::gt() |>
  gt::tab_header(title = "Post-fix: merged_date now populated when any source has a timestamp")

# Check: any missing merged dates?
miss_merged_date <- dat |>
  filter(is.na(merged_date)) |>
  select(p_participant_id, ps_date, p_ps_date, screen_doe, date_baseline, p_date_baseline)

gt::gt(miss_merged_date) |>
  gt::tab_header(title = "Check: Remaining missing merged_date (should be few/none)")
```

# 3) Preeligibility Counts & Data Issues 
```{r warning=FALSE, message=FALSE}
youth_approached_n <- n_distinct_na(dat$p_participant_id)

no_legal_guardian <- dat |>
  filter(over_18 == 0, p_screen_legal_guardian == 0) |>
  select(p_participant_id)
no_legal_guardian_n <- nrow(no_legal_guardian)

no_english <- dat |>
  filter(p_screen_understand_eng == 0) |>
  select(p_participant_id)
no_english_n <- nrow(no_english)

list(
  youth_approached_n = youth_approached_n,
  under_18_no_guardian_n = no_legal_guardian_n,
  no_english_n = no_english_n
)
```

# 4) Composite "hear_more" + trim to interested 
```{r warning=FALSE, message=FALSE}
dat <- dat |>
  mutate(
    merged_hear_more = coalesce(ps_hear_more, p_ps_hear_more)
  )

# Manual fixes
dat <- dat |>
  mutate(
    merged_hear_more = if_else(p_participant_id %in% c("K-F0006","H-F0115","K-F0250"),
                               1L, merged_hear_more),
    merged_hear_more = replace_na(merged_hear_more, 0L)
  )

consented_to_hear_more_n    <- sum(dat$merged_hear_more == 1, na.rm = TRUE)
did_not_consent_hear_more_n <- sum(dat$merged_hear_more == 0, na.rm = TRUE)

# Check: anyone with treatment assigned but not interested in hearing more?
chk_treat_but_no_interest <- dat |>
  filter(!is.na(treatment), merged_hear_more == 0) |>
  select(p_participant_id, treatment)
gt::gt(chk_treat_but_no_interest) |>
  gt::tab_header(title = "Check: Treatment present but 'hear more' == 0")

# Keep only those interested
dat <- dat |>
  filter(merged_hear_more == 1)
```

# 5) Eligibility Screen Completion 
```{r warning=FALSE, message=FALSE}
dat <- dat |>
  mutate(
    eligibility_screen_complete = replace_na(eligibility_screen_complete, 0L),
    eligibility_screen_complete = if_else(eligibility_screen_complete == 2, 2L, 0L)
  )

did_not_wish_participate_n <- sum(dat$eligibility_screen_complete == 0, na.rm = TRUE)
completed_elg_screen_n     <- sum(dat$eligibility_screen_complete == 2, na.rm = TRUE)

# Trim to completed screens
dat <- dat |>
  filter(eligibility_screen_complete == 2)
```

#6) Eligibility Criteria (Screen) 
```{r warning=FALSE, message=FALSE}
# 6a) Black (any race flags == 1)
dat <- dat |>
  mutate(
    merge_black = pmax(screen_race_1, screen_race_2, screen_race_3, screen_race_4, na.rm = TRUE),
    elg_age = case_when(
      screen_age >= 12 & screen_age < 20 ~ 1L,
      screen_age < 12 ~ 0L,
      screen_age >= 20 ~ 0L,
      TRUE ~ NA_integer_
    ),
    # Manual override
    elg_age = if_else(p_participant_id == "H-F0023", 1L, elg_age)
  )

# 6b) Compose overall screen eligibility
dat <- dat |>
  mutate(
    eligible_screen = 1L,
    eligible_screen = if_else(merge_black == 0, 0L, eligible_screen),
    eligible_screen = if_else(elg_age != 1, 0L, eligible_screen),
    eligible_screen = if_else(screen_speak_read_english == 0, 0L, eligible_screen),#Ask Ashleigh what this means bc it's confusing 
    eligible_screen = if_else(screen_seek_therapy == 1, 0L, eligible_screen),
    eligible_screen = if_else(screen_self_repeat == 1, 0L, eligible_screen),
    eligible_screen = if_else(screen_sibling_repeat == 1, 0L, eligible_screen),
    eligible_screen = if_else(p_screen_sibling_repeat == 1, 0L, eligible_screen),
    eligible_screen = if_else(screen_has_cell_phone == 0 & merged_date < ymd("2025-01-01"), 0L, eligible_screen),
    eligible_screen = replace_na(eligible_screen, 0L)
  )

# Manual fix
dat <- dat |>
  mutate(eligible_screen = if_else(p_participant_id == "H-F0269", 1L, eligible_screen))

# Check: ineligible but has treatment?
gt::gt(
  dat |>
    filter(eligible_screen == 0, !is.na(treatment)) |>
    select(p_participant_id, treatment)
) |> gt::tab_header(title = "Check: eligible_screen==0 but treatment assigned")

# Check: cell phone exclusion before cutoff
gt::gt(
  dat |>
    filter(screen_has_cell_phone == 0) |>
    select(p_participant_id, merged_date, treatment)
) |> gt::tab_header(title = "Info: screen_has_cell_phone == 0")

# Keep eligible only
dat <- dat |>
  filter(eligible_screen == 1)

eligibility_screen_eligible_n <- nrow(dat)
```

# 7) Eligibility Survey Rules
```{r warning=FALSE, message=FALSE}
# Anxiety (sum of dichotomous items)
dat <- dat |>
  mutate(
    eligible_anxiety = rowSums(across(c(eligible_anxiety_1, eligible_anxiety_2)), na.rm = FALSE),
    eligible_anxious = case_when(
      !is.na(eligible_anxiety) & eligible_anxiety >= 4 ~ 1L,
      !is.na(eligible_anxiety) & eligible_anxiety <  4 ~ 0L,
      TRUE ~ NA_integer_
    ),
    eligible_depress = rowSums(across(c(eligible_depress_1, eligible_depress_2)), na.rm = FALSE),
    eligible_depression = case_when(
      !is.na(eligible_depress) & eligible_depress >= 4 ~ 1L,
      !is.na(eligible_depress) & eligible_depress <  4 ~ 0L,
      TRUE ~ NA_integer_
    ),
    eligible_sch_close = case_when(
      eligible_sch_connect_1 < 3 ~ 1L,
      eligible_sch_connect_1 >=3 ~ 0L,
      TRUE ~ NA_integer_
    ),
    eligible_sch_part = case_when(
      eligible_sch_connect_2 < 3 ~ 1L,
      eligible_sch_connect_2 >=3 ~ 0L,
      TRUE ~ NA_integer_
    ),
    eligible_self_harm_y = case_when(
      eligible_self_harm >= 1 ~ 1L,
      eligible_self_harm == 0 ~ 0L,
      TRUE ~ NA_integer_
    ),
    eligible_sleep_problem_y = case_when(
      eligible_sleep_problem_1 > 1 ~ 1L,
      eligible_sleep_problem_1 <=1 ~ 0L,
      TRUE ~ NA_integer_
    )
  )

# How many survey items answered?
dat <- dat |>
  mutate(
    eligible_survey_count = rowSums(across(c(
      eligible_visited_ed,
      eligible_hospitalized,
      eligible_taken_med,
      eligible_received_therapy,
      eligible_sought_counseling,
      eligible_anxious,
      eligible_depression,
      eligible_sch_close,
      eligible_sch_part,
      eligible_self_harm_y,
      eligible_sleep_problem_y
    ), ~!is.na(.x)))
  )

# Overall survey eligibility (any positive), with date rule + manual inclusions
dat <- dat |>
  mutate(
    eligible_survey = case_when(
      eligible_survey_count <= 8 ~ NA_integer_,
      TRUE ~ if_else(rowSums(across(c(
        eligible_visited_ed,
        eligible_hospitalized,
        eligible_taken_med,
        eligible_received_therapy,
        eligible_sought_counseling,
        eligible_anxious,
        eligible_depression,
        eligible_sch_close,
        eligible_sch_part,
        eligible_self_harm_y,
        eligible_sleep_problem_y
      ), \(x) replace_na(x,0))) >= 1, 1L, 0L)
    ),
    eligible_survey = if_else(merged_date > ymd("2024-12-04"), 1L, eligible_survey),
    eligible_survey = if_else(p_participant_id %in% c("K-F0082","K-F0080"), 1L, eligible_survey)
  )

completed_eligibility_survey_n <- sum(!is.na(dat$eligible_survey))
eligibility_survey_eligible_n  <- sum(dat$eligible_survey == 1, na.rm = TRUE)
eligibility_survey_ineligible_n<- sum(dat$eligible_survey == 0, na.rm = TRUE)
did_not_wish_after_screen_n    <- eligibility_screen_eligible_n - completed_eligibility_survey_n

# Keep only survey-eligible
dat <- dat |>
  filter(eligible_survey == 1)
```

# 8) Consent + Randomization 
```{r warning=FALSE, message=FALSE}
dat <- dat |>
  mutate(
    consent = case_when(
      p_informed_consent_form_parent_complete == 2 & screen_age_group == 0 ~ 1L,
      informed_consent_form_youth_complete  == 2 & screen_age_group == 1 ~ 1L,
      p_participant_id %in% c("H-F0115","H-F0085") ~ 1L,  # verbal / form issues
      TRUE ~ 0L
    )
  )

consented_n <- sum(dat$consent == 1, na.rm = TRUE)
did_not_consent_n <- sum(dat$consent == 0, na.rm = TRUE)

# Checks
gt::gt(
  dat |> filter(!is.na(treatment) & consent != 1) |>
    select(p_participant_id, treatment, consent)
) |> gt::tab_header(title = "Check: Has treatment but consent != 1")

gt::gt(
  dat |> filter(is.na(treatment) & consent == 1) |>
    select(p_participant_id)
) |> gt::tab_header(title = "Check: Consented but no treatment")

# CONSORT counters
did_not_complete_baseline_n <- sum(is.na(dat$treatment) & dat$consent == 1)
randomized_n <- sum(!is.na(dat$treatment))

treatment_n <- sum(dat$treatment == 1, na.rm = TRUE)
control_n   <- sum(dat$treatment == 0, na.rm = TRUE)

# Keep only randomized for follow-up splits
rand <- dat |> filter(!is.na(treatment))
```

# 9) Follow-ups: 3-Month & 6-Month
```{r warning=FALSE, message=FALSE}
# Map to 4 categories
map_status <- function(v){
  dplyr::case_when(
    v == 1 ~ "Completed",
    v %in% 2:5 ~ "Active",
    v == 6 ~ "Withdrawal",
    v == 7 ~ "Missed",
    TRUE   ~ NA_character_
  )
}

rand <- rand |>
  mutate(
    consort_status_3m = map_status(follow_visitstatus_3m),
    consort_status_6m = map_status(follow_visitstatus_6m)
  ) |>
  # Rule: if exited at 3m, keep exited in 6m
  mutate(
    consort_status_6m = if_else(consort_status_3m == "Withdrawal", "Withdrawal", consort_status_6m)
  )

# Count helper
count_by_arm <- function(status_col, arm){
  sum(rand[[status_col]] == "Completed" & rand$treatment == arm, na.rm = TRUE) %>% 
    list(
      completed = .,
      active    = sum(rand[[status_col]] == "Active"    & rand$treatment == arm, na.rm = TRUE),
      missed    = sum(rand[[status_col]] == "Missed"    & rand$treatment == arm, na.rm = TRUE),
      exited    = sum(rand[[status_col]] == "Withdrawal"& rand$treatment == arm, na.rm = TRUE)
    )
}

n3_t <- count_by_arm("consort_status_3m", 1)
n3_c <- count_by_arm("consort_status_3m", 0)

n6_t <- count_by_arm("consort_status_6m", 1)
n6_c <- count_by_arm("consort_status_6m", 0)

# Totals shown under each 3m/6m box
n3_t_total <- sum(rand$treatment==1 & !is.na(rand$consort_status_3m))
n3_c_total <- sum(rand$treatment==0 & !is.na(rand$consort_status_3m))
n6_t_total <- sum(rand$treatment==1 & !is.na(rand$consort_status_6m))
n6_c_total <- sum(rand$treatment==0 & !is.na(rand$consort_status_6m))
```

# 10) CONSORT Diagram 
```{r warning=FALSE, message=FALSE}
# 10) CONSORT Diagram (robust)
{
  # Labels already computed above in `lbl`

  try_consort <- requireNamespace("consort", quietly = TRUE) &&
                 !identical(Sys.getenv("WECARE_DISABLE_CONSORT"), "1")

  if (try_consort) {
    ok <- TRUE
    g <- try({
      library(consort)
      add_box() |>
        add_box("top", txt = lbl$top) |>
        add_box("hear_more_y", parent = "top", txt = lbl$hear_more_y) |>
        add_side_box("hear_more_n", "hear_more_y", txt = lbl$hear_more_n) |>
        add_box("elg_screen_cmpl", parent = "hear_more_y", txt = lbl$elg_screen_cmpl) |>
        add_side_box("elg_screen_incmp", "elg_screen_cmpl", txt = lbl$elg_screen_incmp) |>
        add_box("elg_screen_elig", parent = "elg_screen_cmpl", txt = lbl$elg_screen_elig) |>
        add_box("elg_svy_total", parent = "elg_screen_elig", txt = lbl$elg_svy_total) |>
        add_side_box("elg_svy_inelig", "elg_svy_total", txt = lbl$elg_svy_inelig) |>
        add_box("elg_svy_elig", parent = "elg_svy_total", txt = lbl$elg_svy_elig) |>
        add_box("consented", parent = "elg_svy_elig", txt = lbl$consented) |>
        add_side_box("did_not_consent", "consented", txt = lbl$did_not_consent) |>
        add_box("randomized", parent = "consented", txt = lbl$randomized) |>
        add_side_box("did_not_baseline", "randomized", txt = lbl$did_not_baseline) |>
        add_box("arm_t", parent = "randomized", txt = lbl$arm_t, just = "left") |>
        add_box("arm_c", parent = "randomized", txt = lbl$arm_c, just = "right") |>
        add_box("m3_t", parent = "arm_t", txt = lbl$m3_t) |>
        add_box("m3_c", parent = "arm_c", txt = lbl$m3_c) |>
        add_box("m3_t_breakdown", parent = "m3_t", txt = lbl$m3_t_breakdown, just = "left") |>
        add_box("m3_c_breakdown", parent = "m3_c", txt = lbl$m3_c_breakdown, just = "right") |>
        add_box("m6_t", parent = "m3_t", txt = lbl$m6_t) |>
        add_box("m6_c", parent = "m3_c", txt = lbl$m6_c) |>
        add_box("m6_t_breakdown", parent = "m6_t", txt = lbl$m6_t_breakdown, just = "left") |>
        add_box("m6_c_breakdown", parent = "m6_c", txt = lbl$m6_c_breakdown, just = "right")
    }, silent = TRUE)

    if (inherits(g, "try-error")) {
      ok <- FALSE
    } else {
      # Explicit wrap width avoids `stri_wrap` error
      ok <- !inherits(try(consort::plot(g, text_width = 64), silent = TRUE), "try-error")
    }

    if (ok) {
      invisible(NULL)  # already plotted
    } else {
      message("CONSORT package plot failed; falling back to DiagrammeR.")
      try_consort <- FALSE
    }
  }

  if (!try_consort) {
    dot <- glue::glue('
    digraph consort {{
      graph [rankdir=TB, splines=ortho, nodesep="0.3", ranksep="0.35"];
      node [shape=box, style="rounded,filled", fillcolor="white", color="black", fontname="Helvetica", fontsize=10];
      edge [arrowhead=normal];

      top    [label="{lbl$top}"];
      hm_y   [label="{lbl$hear_more_y}"];
      hm_n   [label="{lbl$hear_more_n}"];
      elg_c  [label="{lbl$elg_screen_cmpl}"];
      elg_dn [label="{lbl$elg_screen_incmp}"];
      elg_e  [label="{lbl$elg_screen_elig}"];
      svy_t  [label="{lbl$elg_svy_total}"];
      svy_i  [label="{lbl$elg_svy_inelig}"];
      svy_e  [label="{lbl$elg_svy_elig}"];
      cons   [label="{lbl$consented}"];
      ncons  [label="{lbl$did_not_consent}"];
      rand   [label="{lbl$randomized}"];
      nbase  [label="{lbl$did_not_baseline}"];
      arm_t  [label="{lbl$arm_t}"];
      arm_c  [label="{lbl$arm_c}"];
      m3_t   [label="{lbl$m3_t}"];
      m3_c   [label="{lbl$m3_c}"];
      m3_tb  [label="{lbl$m3_t_breakdown}"];
      m3_cb  [label="{lbl$m3_c_breakdown}"];
      m6_t   [label="{lbl$m6_t}"];
      m6_c   [label="{lbl$m6_c}"];
      m6_tb  [label="{lbl$m6_t_breakdown}"];
      m6_cb  [label="{lbl$m6_c_breakdown}"];

      top -> hm_y;   top -> hm_n [constraint=false];
      hm_y -> elg_c; elg_c -> elg_dn [constraint=false]; elg_c -> elg_e;
      elg_e -> svy_t; svy_t -> svy_i [constraint=false]; svy_t -> svy_e;
      svy_e -> cons;  cons -> ncons [constraint=false]; cons -> rand; rand -> nbase [constraint=false];
      rand -> arm_t;  rand -> arm_c;
      arm_t -> m3_t;  arm_c -> m3_c;
      m3_t -> m3_tb;  m3_c -> m3_cb;
      m3_t -> m6_t;   m3_c -> m6_c;
      m6_t -> m6_tb;  m6_c -> m6_cb;
    }}
    ')
    DiagrammeR::grViz(dot)
  }
}
```

# 11) QC Summary Quick Table 
```{r warning=FALSE, message=FALSE}
tibble::tibble(
  metric = c(
    "Youth approached in ER",
    "Consented to hear more",
    "Did not consent to hear more",
    "Completed Eligibility Screen",
    "Did not wish to participate (pre-survey)",
    "Eligibility Screen: Eligible",
    "Completed Eligibility Survey (total)",
    "Eligibility Survey: Eligible",
    "Eligibility Survey: Ineligible",
    "Consented",
    "Did not consent",
    "Did not complete baseline",
    "Randomized (any arm)",
    "Treatment (n)",
    "Control (n)"
  ),
  n = c(
    youth_approached_n,
    consented_to_hear_more_n,
    did_not_consent_hear_more_n,
    completed_elg_screen_n,
    did_not_wish_participate_n,
    eligibility_screen_eligible_n,
    completed_eligibility_survey_n,
    eligibility_survey_eligible_n,
    eligibility_survey_ineligible_n,
    consented_n,
    did_not_consent_n,
    did_not_complete_baseline_n,
    randomized_n,
    treatment_n,
    control_n
  )
) |>
  gt::gt() |>
  gt::tab_header(title = "CONSORT — Count Summary")
```
